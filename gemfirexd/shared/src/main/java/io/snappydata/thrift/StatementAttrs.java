/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package io.snappydata.thrift;

import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import org.apache.thrift.async.AsyncMethodCallback;
import org.apache.thrift.server.AbstractNonblockingServer.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import javax.annotation.Generated;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2017-11-17")
public class StatementAttrs implements org.apache.thrift.TBase<StatementAttrs, StatementAttrs._Fields>, java.io.Serializable, Cloneable, Comparable<StatementAttrs> {
  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("StatementAttrs");

  private static final org.apache.thrift.protocol.TField RESULT_SET_TYPE_FIELD_DESC = new org.apache.thrift.protocol.TField("resultSetType", org.apache.thrift.protocol.TType.BYTE, (short)1);
  private static final org.apache.thrift.protocol.TField UPDATABLE_FIELD_DESC = new org.apache.thrift.protocol.TField("updatable", org.apache.thrift.protocol.TType.BOOL, (short)2);
  private static final org.apache.thrift.protocol.TField HOLD_CURSORS_OVER_COMMIT_FIELD_DESC = new org.apache.thrift.protocol.TField("holdCursorsOverCommit", org.apache.thrift.protocol.TType.BOOL, (short)3);
  private static final org.apache.thrift.protocol.TField REQUIRE_AUTO_INC_COLS_FIELD_DESC = new org.apache.thrift.protocol.TField("requireAutoIncCols", org.apache.thrift.protocol.TType.BOOL, (short)4);
  private static final org.apache.thrift.protocol.TField AUTO_INC_COLUMNS_FIELD_DESC = new org.apache.thrift.protocol.TField("autoIncColumns", org.apache.thrift.protocol.TType.LIST, (short)5);
  private static final org.apache.thrift.protocol.TField AUTO_INC_COLUMN_NAMES_FIELD_DESC = new org.apache.thrift.protocol.TField("autoIncColumnNames", org.apache.thrift.protocol.TType.LIST, (short)6);
  private static final org.apache.thrift.protocol.TField BATCH_SIZE_FIELD_DESC = new org.apache.thrift.protocol.TField("batchSize", org.apache.thrift.protocol.TType.I32, (short)7);
  private static final org.apache.thrift.protocol.TField FETCH_REVERSE_FIELD_DESC = new org.apache.thrift.protocol.TField("fetchReverse", org.apache.thrift.protocol.TType.BOOL, (short)8);
  private static final org.apache.thrift.protocol.TField LOB_CHUNK_SIZE_FIELD_DESC = new org.apache.thrift.protocol.TField("lobChunkSize", org.apache.thrift.protocol.TType.I32, (short)9);
  private static final org.apache.thrift.protocol.TField MAX_ROWS_FIELD_DESC = new org.apache.thrift.protocol.TField("maxRows", org.apache.thrift.protocol.TType.I32, (short)10);
  private static final org.apache.thrift.protocol.TField MAX_FIELD_SIZE_FIELD_DESC = new org.apache.thrift.protocol.TField("maxFieldSize", org.apache.thrift.protocol.TType.I32, (short)11);
  private static final org.apache.thrift.protocol.TField TIMEOUT_FIELD_DESC = new org.apache.thrift.protocol.TField("timeout", org.apache.thrift.protocol.TType.I32, (short)12);
  private static final org.apache.thrift.protocol.TField CURSOR_NAME_FIELD_DESC = new org.apache.thrift.protocol.TField("cursorName", org.apache.thrift.protocol.TType.STRING, (short)13);
  private static final org.apache.thrift.protocol.TField POSSIBLE_DUPLICATE_FIELD_DESC = new org.apache.thrift.protocol.TField("possibleDuplicate", org.apache.thrift.protocol.TType.BOOL, (short)14);
  private static final org.apache.thrift.protocol.TField POOLABLE_FIELD_DESC = new org.apache.thrift.protocol.TField("poolable", org.apache.thrift.protocol.TType.BOOL, (short)15);
  private static final org.apache.thrift.protocol.TField DO_ESCAPE_PROCESSING_FIELD_DESC = new org.apache.thrift.protocol.TField("doEscapeProcessing", org.apache.thrift.protocol.TType.BOOL, (short)16);
  private static final org.apache.thrift.protocol.TField PENDING_TRANSACTION_ATTRS_FIELD_DESC = new org.apache.thrift.protocol.TField("pendingTransactionAttrs", org.apache.thrift.protocol.TType.MAP, (short)17);
  private static final org.apache.thrift.protocol.TField BUCKET_IDS_FIELD_DESC = new org.apache.thrift.protocol.TField("bucketIds", org.apache.thrift.protocol.TType.SET, (short)18);
  private static final org.apache.thrift.protocol.TField BUCKET_IDS_TABLE_FIELD_DESC = new org.apache.thrift.protocol.TField("bucketIdsTable", org.apache.thrift.protocol.TType.STRING, (short)19);
  private static final org.apache.thrift.protocol.TField RETAIN_BUCKET_IDS_FIELD_DESC = new org.apache.thrift.protocol.TField("retainBucketIds", org.apache.thrift.protocol.TType.BOOL, (short)20);
  private static final org.apache.thrift.protocol.TField METADATA_VERSION_FIELD_DESC = new org.apache.thrift.protocol.TField("metadataVersion", org.apache.thrift.protocol.TType.I32, (short)21);
  private static final org.apache.thrift.protocol.TField SNAPSHOT_TRANSACTION_ID_FIELD_DESC = new org.apache.thrift.protocol.TField("snapshotTransactionId", org.apache.thrift.protocol.TType.STRING, (short)22);

  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
  static {
    schemes.put(StandardScheme.class, new StatementAttrsStandardSchemeFactory());
    schemes.put(TupleScheme.class, new StatementAttrsTupleSchemeFactory());
  }

  public byte resultSetType; // optional
  public boolean updatable; // optional
  public boolean holdCursorsOverCommit; // optional
  public boolean requireAutoIncCols; // optional
  public List<Integer> autoIncColumns; // optional
  public List<String> autoIncColumnNames; // optional
  public int batchSize; // optional
  public boolean fetchReverse; // optional
  public int lobChunkSize; // optional
  public int maxRows; // optional
  public int maxFieldSize; // optional
  public int timeout; // optional
  public String cursorName; // optional
  public boolean possibleDuplicate; // optional
  public boolean poolable; // optional
  public boolean doEscapeProcessing; // optional
  public Map<TransactionAttribute,Boolean> pendingTransactionAttrs; // optional
  public Set<Integer> bucketIds; // optional
  public String bucketIdsTable; // optional
  public boolean retainBucketIds; // optional
  public int metadataVersion; // optional
  public String snapshotTransactionId; // optional

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
    RESULT_SET_TYPE((short)1, "resultSetType"),
    UPDATABLE((short)2, "updatable"),
    HOLD_CURSORS_OVER_COMMIT((short)3, "holdCursorsOverCommit"),
    REQUIRE_AUTO_INC_COLS((short)4, "requireAutoIncCols"),
    AUTO_INC_COLUMNS((short)5, "autoIncColumns"),
    AUTO_INC_COLUMN_NAMES((short)6, "autoIncColumnNames"),
    BATCH_SIZE((short)7, "batchSize"),
    FETCH_REVERSE((short)8, "fetchReverse"),
    LOB_CHUNK_SIZE((short)9, "lobChunkSize"),
    MAX_ROWS((short)10, "maxRows"),
    MAX_FIELD_SIZE((short)11, "maxFieldSize"),
    TIMEOUT((short)12, "timeout"),
    CURSOR_NAME((short)13, "cursorName"),
    POSSIBLE_DUPLICATE((short)14, "possibleDuplicate"),
    POOLABLE((short)15, "poolable"),
    DO_ESCAPE_PROCESSING((short)16, "doEscapeProcessing"),
    PENDING_TRANSACTION_ATTRS((short)17, "pendingTransactionAttrs"),
    BUCKET_IDS((short)18, "bucketIds"),
    BUCKET_IDS_TABLE((short)19, "bucketIdsTable"),
    RETAIN_BUCKET_IDS((short)20, "retainBucketIds"),
    METADATA_VERSION((short)21, "metadataVersion"),
    SNAPSHOT_TRANSACTION_ID((short)22, "snapshotTransactionId");

    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // RESULT_SET_TYPE
          return RESULT_SET_TYPE;
        case 2: // UPDATABLE
          return UPDATABLE;
        case 3: // HOLD_CURSORS_OVER_COMMIT
          return HOLD_CURSORS_OVER_COMMIT;
        case 4: // REQUIRE_AUTO_INC_COLS
          return REQUIRE_AUTO_INC_COLS;
        case 5: // AUTO_INC_COLUMNS
          return AUTO_INC_COLUMNS;
        case 6: // AUTO_INC_COLUMN_NAMES
          return AUTO_INC_COLUMN_NAMES;
        case 7: // BATCH_SIZE
          return BATCH_SIZE;
        case 8: // FETCH_REVERSE
          return FETCH_REVERSE;
        case 9: // LOB_CHUNK_SIZE
          return LOB_CHUNK_SIZE;
        case 10: // MAX_ROWS
          return MAX_ROWS;
        case 11: // MAX_FIELD_SIZE
          return MAX_FIELD_SIZE;
        case 12: // TIMEOUT
          return TIMEOUT;
        case 13: // CURSOR_NAME
          return CURSOR_NAME;
        case 14: // POSSIBLE_DUPLICATE
          return POSSIBLE_DUPLICATE;
        case 15: // POOLABLE
          return POOLABLE;
        case 16: // DO_ESCAPE_PROCESSING
          return DO_ESCAPE_PROCESSING;
        case 17: // PENDING_TRANSACTION_ATTRS
          return PENDING_TRANSACTION_ATTRS;
        case 18: // BUCKET_IDS
          return BUCKET_IDS;
        case 19: // BUCKET_IDS_TABLE
          return BUCKET_IDS_TABLE;
        case 20: // RETAIN_BUCKET_IDS
          return RETAIN_BUCKET_IDS;
        case 21: // METADATA_VERSION
          return METADATA_VERSION;
        case 22: // SNAPSHOT_TRANSACTION_ID
          return SNAPSHOT_TRANSACTION_ID;
        default:
          return null;
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }

    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }

    private final short _thriftId;
    private final String _fieldName;

    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }

    public short getThriftFieldId() {
      return _thriftId;
    }

    public String getFieldName() {
      return _fieldName;
    }
  }

  // isset id assignments
  private static final int __RESULTSETTYPE_ISSET_ID = 0;
  private static final int __UPDATABLE_ISSET_ID = 1;
  private static final int __HOLDCURSORSOVERCOMMIT_ISSET_ID = 2;
  private static final int __REQUIREAUTOINCCOLS_ISSET_ID = 3;
  private static final int __BATCHSIZE_ISSET_ID = 4;
  private static final int __FETCHREVERSE_ISSET_ID = 5;
  private static final int __LOBCHUNKSIZE_ISSET_ID = 6;
  private static final int __MAXROWS_ISSET_ID = 7;
  private static final int __MAXFIELDSIZE_ISSET_ID = 8;
  private static final int __TIMEOUT_ISSET_ID = 9;
  private static final int __POSSIBLEDUPLICATE_ISSET_ID = 10;
  private static final int __POOLABLE_ISSET_ID = 11;
  private static final int __DOESCAPEPROCESSING_ISSET_ID = 12;
  private static final int __RETAINBUCKETIDS_ISSET_ID = 13;
  private static final int __METADATAVERSION_ISSET_ID = 14;
  public short __isset_bitfield = 0;
  private static final _Fields optionals[] = {_Fields.RESULT_SET_TYPE,_Fields.UPDATABLE,_Fields.HOLD_CURSORS_OVER_COMMIT,_Fields.REQUIRE_AUTO_INC_COLS,_Fields.AUTO_INC_COLUMNS,_Fields.AUTO_INC_COLUMN_NAMES,_Fields.BATCH_SIZE,_Fields.FETCH_REVERSE,_Fields.LOB_CHUNK_SIZE,_Fields.MAX_ROWS,_Fields.MAX_FIELD_SIZE,_Fields.TIMEOUT,_Fields.CURSOR_NAME,_Fields.POSSIBLE_DUPLICATE,_Fields.POOLABLE,_Fields.DO_ESCAPE_PROCESSING,_Fields.PENDING_TRANSACTION_ATTRS,_Fields.BUCKET_IDS,_Fields.BUCKET_IDS_TABLE,_Fields.RETAIN_BUCKET_IDS,_Fields.METADATA_VERSION,_Fields.SNAPSHOT_TRANSACTION_ID};
  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
  static {
    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.RESULT_SET_TYPE, new org.apache.thrift.meta_data.FieldMetaData("resultSetType", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BYTE)));
    tmpMap.put(_Fields.UPDATABLE, new org.apache.thrift.meta_data.FieldMetaData("updatable", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.HOLD_CURSORS_OVER_COMMIT, new org.apache.thrift.meta_data.FieldMetaData("holdCursorsOverCommit", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.REQUIRE_AUTO_INC_COLS, new org.apache.thrift.meta_data.FieldMetaData("requireAutoIncCols", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.AUTO_INC_COLUMNS, new org.apache.thrift.meta_data.FieldMetaData("autoIncColumns", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32))));
    tmpMap.put(_Fields.AUTO_INC_COLUMN_NAMES, new org.apache.thrift.meta_data.FieldMetaData("autoIncColumnNames", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.ListMetaData(org.apache.thrift.protocol.TType.LIST, 
            new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING))));
    tmpMap.put(_Fields.BATCH_SIZE, new org.apache.thrift.meta_data.FieldMetaData("batchSize", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.FETCH_REVERSE, new org.apache.thrift.meta_data.FieldMetaData("fetchReverse", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.LOB_CHUNK_SIZE, new org.apache.thrift.meta_data.FieldMetaData("lobChunkSize", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MAX_ROWS, new org.apache.thrift.meta_data.FieldMetaData("maxRows", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.MAX_FIELD_SIZE, new org.apache.thrift.meta_data.FieldMetaData("maxFieldSize", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.TIMEOUT, new org.apache.thrift.meta_data.FieldMetaData("timeout", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.CURSOR_NAME, new org.apache.thrift.meta_data.FieldMetaData("cursorName", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.POSSIBLE_DUPLICATE, new org.apache.thrift.meta_data.FieldMetaData("possibleDuplicate", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.POOLABLE, new org.apache.thrift.meta_data.FieldMetaData("poolable", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.DO_ESCAPE_PROCESSING, new org.apache.thrift.meta_data.FieldMetaData("doEscapeProcessing", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.PENDING_TRANSACTION_ATTRS, new org.apache.thrift.meta_data.FieldMetaData("pendingTransactionAttrs", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.MapMetaData(org.apache.thrift.protocol.TType.MAP, 
            new org.apache.thrift.meta_data.EnumMetaData(org.apache.thrift.protocol.TType.ENUM, TransactionAttribute.class), 
            new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL))));
    tmpMap.put(_Fields.BUCKET_IDS, new org.apache.thrift.meta_data.FieldMetaData("bucketIds", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.SetMetaData(org.apache.thrift.protocol.TType.SET, 
            new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32))));
    tmpMap.put(_Fields.BUCKET_IDS_TABLE, new org.apache.thrift.meta_data.FieldMetaData("bucketIdsTable", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.RETAIN_BUCKET_IDS, new org.apache.thrift.meta_data.FieldMetaData("retainBucketIds", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.METADATA_VERSION, new org.apache.thrift.meta_data.FieldMetaData("metadataVersion", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.SNAPSHOT_TRANSACTION_ID, new org.apache.thrift.meta_data.FieldMetaData("snapshotTransactionId", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(StatementAttrs.class, metaDataMap);
  }

  public StatementAttrs() {
    this.batchSize = 8192;

  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public StatementAttrs(StatementAttrs other) {
    __isset_bitfield = other.__isset_bitfield;
    this.resultSetType = other.resultSetType;
    this.updatable = other.updatable;
    this.holdCursorsOverCommit = other.holdCursorsOverCommit;
    this.requireAutoIncCols = other.requireAutoIncCols;
    if (other.isSetAutoIncColumns()) {
      List<Integer> __this__autoIncColumns = new ArrayList<Integer>(other.autoIncColumns);
      this.autoIncColumns = __this__autoIncColumns;
    }
    if (other.isSetAutoIncColumnNames()) {
      List<String> __this__autoIncColumnNames = new ArrayList<String>(other.autoIncColumnNames);
      this.autoIncColumnNames = __this__autoIncColumnNames;
    }
    this.batchSize = other.batchSize;
    this.fetchReverse = other.fetchReverse;
    this.lobChunkSize = other.lobChunkSize;
    this.maxRows = other.maxRows;
    this.maxFieldSize = other.maxFieldSize;
    this.timeout = other.timeout;
    if (other.isSetCursorName()) {
      this.cursorName = other.cursorName;
    }
    this.possibleDuplicate = other.possibleDuplicate;
    this.poolable = other.poolable;
    this.doEscapeProcessing = other.doEscapeProcessing;
    if (other.isSetPendingTransactionAttrs()) {
      Map<TransactionAttribute,Boolean> __this__pendingTransactionAttrs = new HashMap<TransactionAttribute,Boolean>(other.pendingTransactionAttrs.size());
      for (Map.Entry<TransactionAttribute, Boolean> other_element : other.pendingTransactionAttrs.entrySet()) {

        TransactionAttribute other_element_key = other_element.getKey();
        Boolean other_element_value = other_element.getValue();

        TransactionAttribute __this__pendingTransactionAttrs_copy_key = other_element_key;

        Boolean __this__pendingTransactionAttrs_copy_value = other_element_value;

        __this__pendingTransactionAttrs.put(__this__pendingTransactionAttrs_copy_key, __this__pendingTransactionAttrs_copy_value);
      }
      this.pendingTransactionAttrs = __this__pendingTransactionAttrs;
    }
    if (other.isSetBucketIds()) {
      Set<Integer> __this__bucketIds = new HashSet<Integer>(other.bucketIds);
      this.bucketIds = __this__bucketIds;
    }
    if (other.isSetBucketIdsTable()) {
      this.bucketIdsTable = other.bucketIdsTable;
    }
    this.retainBucketIds = other.retainBucketIds;
    this.metadataVersion = other.metadataVersion;
    if (other.isSetSnapshotTransactionId()) {
      this.snapshotTransactionId = other.snapshotTransactionId;
    }
  }

  public StatementAttrs deepCopy() {
    return new StatementAttrs(this);
  }

  @Override
  public void clear() {
    setResultSetTypeIsSet(false);
    this.resultSetType = 0;
    setUpdatableIsSet(false);
    this.updatable = false;
    setHoldCursorsOverCommitIsSet(false);
    this.holdCursorsOverCommit = false;
    setRequireAutoIncColsIsSet(false);
    this.requireAutoIncCols = false;
    this.autoIncColumns = null;
    this.autoIncColumnNames = null;
    this.batchSize = 8192;

    setFetchReverseIsSet(false);
    this.fetchReverse = false;
    setLobChunkSizeIsSet(false);
    this.lobChunkSize = 0;
    setMaxRowsIsSet(false);
    this.maxRows = 0;
    setMaxFieldSizeIsSet(false);
    this.maxFieldSize = 0;
    setTimeoutIsSet(false);
    this.timeout = 0;
    this.cursorName = null;
    setPossibleDuplicateIsSet(false);
    this.possibleDuplicate = false;
    setPoolableIsSet(false);
    this.poolable = false;
    setDoEscapeProcessingIsSet(false);
    this.doEscapeProcessing = false;
    this.pendingTransactionAttrs = null;
    this.bucketIds = null;
    this.bucketIdsTable = null;
    setRetainBucketIdsIsSet(false);
    this.retainBucketIds = false;
    setMetadataVersionIsSet(false);
    this.metadataVersion = 0;
    this.snapshotTransactionId = null;
  }

  public byte getResultSetType() {
    return isSetResultSetType() ? this.resultSetType
        : snappydataConstants.DEFAULT_RESULTSET_TYPE;
  }

  public StatementAttrs setResultSetType(byte resultSetType) {
    this.resultSetType = resultSetType;
    setResultSetTypeIsSet(true);
    return this;
  }

  public void unsetResultSetType() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __RESULTSETTYPE_ISSET_ID);
  }

  /** Returns true if field resultSetType is set (has been assigned a value) and false otherwise */
  public boolean isSetResultSetType() {
    return EncodingUtils.testBit(__isset_bitfield, __RESULTSETTYPE_ISSET_ID);
  }

  public void setResultSetTypeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __RESULTSETTYPE_ISSET_ID, value);
  }

  public boolean isUpdatable() {
    return this.updatable;
  }

  public StatementAttrs setUpdatable(boolean updatable) {
    this.updatable = updatable;
    setUpdatableIsSet(true);
    return this;
  }

  public void unsetUpdatable() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __UPDATABLE_ISSET_ID);
  }

  /** Returns true if field updatable is set (has been assigned a value) and false otherwise */
  public boolean isSetUpdatable() {
    return EncodingUtils.testBit(__isset_bitfield, __UPDATABLE_ISSET_ID);
  }

  public void setUpdatableIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __UPDATABLE_ISSET_ID, value);
  }

  public boolean isHoldCursorsOverCommit() {
    return this.holdCursorsOverCommit;
  }

  public StatementAttrs setHoldCursorsOverCommit(boolean holdCursorsOverCommit) {
    this.holdCursorsOverCommit = holdCursorsOverCommit;
    setHoldCursorsOverCommitIsSet(true);
    return this;
  }

  public void unsetHoldCursorsOverCommit() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __HOLDCURSORSOVERCOMMIT_ISSET_ID);
  }

  /** Returns true if field holdCursorsOverCommit is set (has been assigned a value) and false otherwise */
  public boolean isSetHoldCursorsOverCommit() {
    return EncodingUtils.testBit(__isset_bitfield, __HOLDCURSORSOVERCOMMIT_ISSET_ID);
  }

  public void setHoldCursorsOverCommitIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __HOLDCURSORSOVERCOMMIT_ISSET_ID, value);
  }

  public boolean isRequireAutoIncCols() {
    return this.requireAutoIncCols;
  }

  public StatementAttrs setRequireAutoIncCols(boolean requireAutoIncCols) {
    this.requireAutoIncCols = requireAutoIncCols;
    setRequireAutoIncColsIsSet(true);
    return this;
  }

  public void unsetRequireAutoIncCols() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __REQUIREAUTOINCCOLS_ISSET_ID);
  }

  /** Returns true if field requireAutoIncCols is set (has been assigned a value) and false otherwise */
  public boolean isSetRequireAutoIncCols() {
    return EncodingUtils.testBit(__isset_bitfield, __REQUIREAUTOINCCOLS_ISSET_ID);
  }

  public void setRequireAutoIncColsIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __REQUIREAUTOINCCOLS_ISSET_ID, value);
  }

  public int getAutoIncColumnsSize() {
    return (this.autoIncColumns == null) ? 0 : this.autoIncColumns.size();
  }

  public java.util.Iterator<Integer> getAutoIncColumnsIterator() {
    return (this.autoIncColumns == null) ? null : this.autoIncColumns.iterator();
  }

  public void addToAutoIncColumns(int elem) {
    if (this.autoIncColumns == null) {
      this.autoIncColumns = new ArrayList<Integer>();
    }
    this.autoIncColumns.add(elem);
  }

  public List<Integer> getAutoIncColumns() {
    return this.autoIncColumns;
  }

  public StatementAttrs setAutoIncColumns(List<Integer> autoIncColumns) {
    this.autoIncColumns = autoIncColumns;
    return this;
  }

  public void unsetAutoIncColumns() {
    this.autoIncColumns = null;
  }

  /** Returns true if field autoIncColumns is set (has been assigned a value) and false otherwise */
  public boolean isSetAutoIncColumns() {
    return this.autoIncColumns != null;
  }

  public void setAutoIncColumnsIsSet(boolean value) {
    if (!value) {
      this.autoIncColumns = null;
    }
  }

  public int getAutoIncColumnNamesSize() {
    return (this.autoIncColumnNames == null) ? 0 : this.autoIncColumnNames.size();
  }

  public java.util.Iterator<String> getAutoIncColumnNamesIterator() {
    return (this.autoIncColumnNames == null) ? null : this.autoIncColumnNames.iterator();
  }

  public void addToAutoIncColumnNames(String elem) {
    if (this.autoIncColumnNames == null) {
      this.autoIncColumnNames = new ArrayList<String>();
    }
    this.autoIncColumnNames.add(elem);
  }

  public List<String> getAutoIncColumnNames() {
    return this.autoIncColumnNames;
  }

  public StatementAttrs setAutoIncColumnNames(List<String> autoIncColumnNames) {
    this.autoIncColumnNames = autoIncColumnNames;
    return this;
  }

  public void unsetAutoIncColumnNames() {
    this.autoIncColumnNames = null;
  }

  /** Returns true if field autoIncColumnNames is set (has been assigned a value) and false otherwise */
  public boolean isSetAutoIncColumnNames() {
    return this.autoIncColumnNames != null;
  }

  public void setAutoIncColumnNamesIsSet(boolean value) {
    if (!value) {
      this.autoIncColumnNames = null;
    }
  }

  public int getBatchSize() {
    return this.batchSize;
  }

  public StatementAttrs setBatchSize(int batchSize) {
    this.batchSize = batchSize;
    setBatchSizeIsSet(true);
    return this;
  }

  public void unsetBatchSize() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __BATCHSIZE_ISSET_ID);
  }

  /** Returns true if field batchSize is set (has been assigned a value) and false otherwise */
  public boolean isSetBatchSize() {
    return EncodingUtils.testBit(__isset_bitfield, __BATCHSIZE_ISSET_ID);
  }

  public void setBatchSizeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __BATCHSIZE_ISSET_ID, value);
  }

  public boolean isFetchReverse() {
    return this.fetchReverse;
  }

  public StatementAttrs setFetchReverse(boolean fetchReverse) {
    this.fetchReverse = fetchReverse;
    setFetchReverseIsSet(true);
    return this;
  }

  public void unsetFetchReverse() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __FETCHREVERSE_ISSET_ID);
  }

  /** Returns true if field fetchReverse is set (has been assigned a value) and false otherwise */
  public boolean isSetFetchReverse() {
    return EncodingUtils.testBit(__isset_bitfield, __FETCHREVERSE_ISSET_ID);
  }

  public void setFetchReverseIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __FETCHREVERSE_ISSET_ID, value);
  }

  public int getLobChunkSize() {
    return this.lobChunkSize;
  }

  public StatementAttrs setLobChunkSize(int lobChunkSize) {
    this.lobChunkSize = lobChunkSize;
    setLobChunkSizeIsSet(true);
    return this;
  }

  public void unsetLobChunkSize() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __LOBCHUNKSIZE_ISSET_ID);
  }

  /** Returns true if field lobChunkSize is set (has been assigned a value) and false otherwise */
  public boolean isSetLobChunkSize() {
    return EncodingUtils.testBit(__isset_bitfield, __LOBCHUNKSIZE_ISSET_ID);
  }

  public void setLobChunkSizeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __LOBCHUNKSIZE_ISSET_ID, value);
  }

  public int getMaxRows() {
    return this.maxRows;
  }

  public StatementAttrs setMaxRows(int maxRows) {
    this.maxRows = maxRows;
    setMaxRowsIsSet(true);
    return this;
  }

  public void unsetMaxRows() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MAXROWS_ISSET_ID);
  }

  /** Returns true if field maxRows is set (has been assigned a value) and false otherwise */
  public boolean isSetMaxRows() {
    return EncodingUtils.testBit(__isset_bitfield, __MAXROWS_ISSET_ID);
  }

  public void setMaxRowsIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MAXROWS_ISSET_ID, value);
  }

  public int getMaxFieldSize() {
    return this.maxFieldSize;
  }

  public StatementAttrs setMaxFieldSize(int maxFieldSize) {
    this.maxFieldSize = maxFieldSize;
    setMaxFieldSizeIsSet(true);
    return this;
  }

  public void unsetMaxFieldSize() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __MAXFIELDSIZE_ISSET_ID);
  }

  /** Returns true if field maxFieldSize is set (has been assigned a value) and false otherwise */
  public boolean isSetMaxFieldSize() {
    return EncodingUtils.testBit(__isset_bitfield, __MAXFIELDSIZE_ISSET_ID);
  }

  public void setMaxFieldSizeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __MAXFIELDSIZE_ISSET_ID, value);
  }

  public int getTimeout() {
    return this.timeout;
  }

  public StatementAttrs setTimeout(int timeout) {
    this.timeout = timeout;
    setTimeoutIsSet(true);
    return this;
  }

  public void unsetTimeout() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __TIMEOUT_ISSET_ID);
  }

  /** Returns true if field timeout is set (has been assigned a value) and false otherwise */
  public boolean isSetTimeout() {
    return EncodingUtils.testBit(__isset_bitfield, __TIMEOUT_ISSET_ID);
  }

  public void setTimeoutIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __TIMEOUT_ISSET_ID, value);
  }

  public String getCursorName() {
    return this.cursorName;
  }

  public StatementAttrs setCursorName(String cursorName) {
    this.cursorName = cursorName;
    return this;
  }

  public void unsetCursorName() {
    this.cursorName = null;
  }

  /** Returns true if field cursorName is set (has been assigned a value) and false otherwise */
  public boolean isSetCursorName() {
    return this.cursorName != null;
  }

  public void setCursorNameIsSet(boolean value) {
    if (!value) {
      this.cursorName = null;
    }
  }

  public boolean isPossibleDuplicate() {
    return this.possibleDuplicate;
  }

  public StatementAttrs setPossibleDuplicate(boolean possibleDuplicate) {
    this.possibleDuplicate = possibleDuplicate;
    setPossibleDuplicateIsSet(true);
    return this;
  }

  public void unsetPossibleDuplicate() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __POSSIBLEDUPLICATE_ISSET_ID);
  }

  /** Returns true if field possibleDuplicate is set (has been assigned a value) and false otherwise */
  public boolean isSetPossibleDuplicate() {
    return EncodingUtils.testBit(__isset_bitfield, __POSSIBLEDUPLICATE_ISSET_ID);
  }

  public void setPossibleDuplicateIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __POSSIBLEDUPLICATE_ISSET_ID, value);
  }

  public boolean isPoolable() {
    return this.poolable;
  }

  public StatementAttrs setPoolable(boolean poolable) {
    this.poolable = poolable;
    setPoolableIsSet(true);
    return this;
  }

  public void unsetPoolable() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __POOLABLE_ISSET_ID);
  }

  /** Returns true if field poolable is set (has been assigned a value) and false otherwise */
  public boolean isSetPoolable() {
    return EncodingUtils.testBit(__isset_bitfield, __POOLABLE_ISSET_ID);
  }

  public void setPoolableIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __POOLABLE_ISSET_ID, value);
  }

  public boolean isDoEscapeProcessing() {
    return this.doEscapeProcessing;
  }

  public StatementAttrs setDoEscapeProcessing(boolean doEscapeProcessing) {
    this.doEscapeProcessing = doEscapeProcessing;
    setDoEscapeProcessingIsSet(true);
    return this;
  }

  public void unsetDoEscapeProcessing() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __DOESCAPEPROCESSING_ISSET_ID);
  }

  /** Returns true if field doEscapeProcessing is set (has been assigned a value) and false otherwise */
  public boolean isSetDoEscapeProcessing() {
    return EncodingUtils.testBit(__isset_bitfield, __DOESCAPEPROCESSING_ISSET_ID);
  }

  public void setDoEscapeProcessingIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __DOESCAPEPROCESSING_ISSET_ID, value);
  }

  public int getPendingTransactionAttrsSize() {
    return (this.pendingTransactionAttrs == null) ? 0 : this.pendingTransactionAttrs.size();
  }

  public void putToPendingTransactionAttrs(TransactionAttribute key, boolean val) {
    if (this.pendingTransactionAttrs == null) {
      this.pendingTransactionAttrs = new HashMap<TransactionAttribute,Boolean>();
    }
    this.pendingTransactionAttrs.put(key, val);
  }

  public Map<TransactionAttribute,Boolean> getPendingTransactionAttrs() {
    return this.pendingTransactionAttrs;
  }

  public StatementAttrs setPendingTransactionAttrs(Map<TransactionAttribute,Boolean> pendingTransactionAttrs) {
    this.pendingTransactionAttrs = pendingTransactionAttrs;
    return this;
  }

  public void unsetPendingTransactionAttrs() {
    this.pendingTransactionAttrs = null;
  }

  /** Returns true if field pendingTransactionAttrs is set (has been assigned a value) and false otherwise */
  public boolean isSetPendingTransactionAttrs() {
    return this.pendingTransactionAttrs != null;
  }

  public void setPendingTransactionAttrsIsSet(boolean value) {
    if (!value) {
      this.pendingTransactionAttrs = null;
    }
  }

  public int getBucketIdsSize() {
    return (this.bucketIds == null) ? 0 : this.bucketIds.size();
  }

  public java.util.Iterator<Integer> getBucketIdsIterator() {
    return (this.bucketIds == null) ? null : this.bucketIds.iterator();
  }

  public void addToBucketIds(int elem) {
    if (this.bucketIds == null) {
      this.bucketIds = new HashSet<Integer>();
    }
    this.bucketIds.add(elem);
  }

  public Set<Integer> getBucketIds() {
    return this.bucketIds;
  }

  public StatementAttrs setBucketIds(Set<Integer> bucketIds) {
    this.bucketIds = bucketIds;
    return this;
  }

  public void unsetBucketIds() {
    this.bucketIds = null;
  }

  /** Returns true if field bucketIds is set (has been assigned a value) and false otherwise */
  public boolean isSetBucketIds() {
    return this.bucketIds != null;
  }

  public void setBucketIdsIsSet(boolean value) {
    if (!value) {
      this.bucketIds = null;
    }
  }

  public String getBucketIdsTable() {
    return this.bucketIdsTable;
  }

  public StatementAttrs setBucketIdsTable(String bucketIdsTable) {
    this.bucketIdsTable = bucketIdsTable;
    return this;
  }

  public void unsetBucketIdsTable() {
    this.bucketIdsTable = null;
  }

  /** Returns true if field bucketIdsTable is set (has been assigned a value) and false otherwise */
  public boolean isSetBucketIdsTable() {
    return this.bucketIdsTable != null;
  }

  public void setBucketIdsTableIsSet(boolean value) {
    if (!value) {
      this.bucketIdsTable = null;
    }
  }

  public boolean isRetainBucketIds() {
    return this.retainBucketIds;
  }

  public StatementAttrs setRetainBucketIds(boolean retainBucketIds) {
    this.retainBucketIds = retainBucketIds;
    setRetainBucketIdsIsSet(true);
    return this;
  }

  public void unsetRetainBucketIds() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __RETAINBUCKETIDS_ISSET_ID);
  }

  /** Returns true if field retainBucketIds is set (has been assigned a value) and false otherwise */
  public boolean isSetRetainBucketIds() {
    return EncodingUtils.testBit(__isset_bitfield, __RETAINBUCKETIDS_ISSET_ID);
  }

  public void setRetainBucketIdsIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __RETAINBUCKETIDS_ISSET_ID, value);
  }

  public int getMetadataVersion() {
    return this.metadataVersion;
  }

  public StatementAttrs setMetadataVersion(int metadataVersion) {
    this.metadataVersion = metadataVersion;
    setMetadataVersionIsSet(true);
    return this;
  }

  public void unsetMetadataVersion() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __METADATAVERSION_ISSET_ID);
  }

  /** Returns true if field metadataVersion is set (has been assigned a value) and false otherwise */
  public boolean isSetMetadataVersion() {
    return EncodingUtils.testBit(__isset_bitfield, __METADATAVERSION_ISSET_ID);
  }

  public void setMetadataVersionIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __METADATAVERSION_ISSET_ID, value);
  }

  public String getSnapshotTransactionId() {
    return this.snapshotTransactionId;
  }

  public StatementAttrs setSnapshotTransactionId(String snapshotTransactionId) {
    this.snapshotTransactionId = snapshotTransactionId;
    return this;
  }

  public void unsetSnapshotTransactionId() {
    this.snapshotTransactionId = null;
  }

  /** Returns true if field snapshotTransactionId is set (has been assigned a value) and false otherwise */
  public boolean isSetSnapshotTransactionId() {
    return this.snapshotTransactionId != null;
  }

  public void setSnapshotTransactionIdIsSet(boolean value) {
    if (!value) {
      this.snapshotTransactionId = null;
    }
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case RESULT_SET_TYPE:
      if (value == null) {
        unsetResultSetType();
      } else {
        setResultSetType((Byte)value);
      }
      break;

    case UPDATABLE:
      if (value == null) {
        unsetUpdatable();
      } else {
        setUpdatable((Boolean)value);
      }
      break;

    case HOLD_CURSORS_OVER_COMMIT:
      if (value == null) {
        unsetHoldCursorsOverCommit();
      } else {
        setHoldCursorsOverCommit((Boolean)value);
      }
      break;

    case REQUIRE_AUTO_INC_COLS:
      if (value == null) {
        unsetRequireAutoIncCols();
      } else {
        setRequireAutoIncCols((Boolean)value);
      }
      break;

    case AUTO_INC_COLUMNS:
      if (value == null) {
        unsetAutoIncColumns();
      } else {
        setAutoIncColumns((List<Integer>)value);
      }
      break;

    case AUTO_INC_COLUMN_NAMES:
      if (value == null) {
        unsetAutoIncColumnNames();
      } else {
        setAutoIncColumnNames((List<String>)value);
      }
      break;

    case BATCH_SIZE:
      if (value == null) {
        unsetBatchSize();
      } else {
        setBatchSize((Integer)value);
      }
      break;

    case FETCH_REVERSE:
      if (value == null) {
        unsetFetchReverse();
      } else {
        setFetchReverse((Boolean)value);
      }
      break;

    case LOB_CHUNK_SIZE:
      if (value == null) {
        unsetLobChunkSize();
      } else {
        setLobChunkSize((Integer)value);
      }
      break;

    case MAX_ROWS:
      if (value == null) {
        unsetMaxRows();
      } else {
        setMaxRows((Integer)value);
      }
      break;

    case MAX_FIELD_SIZE:
      if (value == null) {
        unsetMaxFieldSize();
      } else {
        setMaxFieldSize((Integer)value);
      }
      break;

    case TIMEOUT:
      if (value == null) {
        unsetTimeout();
      } else {
        setTimeout((Integer)value);
      }
      break;

    case CURSOR_NAME:
      if (value == null) {
        unsetCursorName();
      } else {
        setCursorName((String)value);
      }
      break;

    case POSSIBLE_DUPLICATE:
      if (value == null) {
        unsetPossibleDuplicate();
      } else {
        setPossibleDuplicate((Boolean)value);
      }
      break;

    case POOLABLE:
      if (value == null) {
        unsetPoolable();
      } else {
        setPoolable((Boolean)value);
      }
      break;

    case DO_ESCAPE_PROCESSING:
      if (value == null) {
        unsetDoEscapeProcessing();
      } else {
        setDoEscapeProcessing((Boolean)value);
      }
      break;

    case PENDING_TRANSACTION_ATTRS:
      if (value == null) {
        unsetPendingTransactionAttrs();
      } else {
        setPendingTransactionAttrs((Map<TransactionAttribute,Boolean>)value);
      }
      break;

    case BUCKET_IDS:
      if (value == null) {
        unsetBucketIds();
      } else {
        setBucketIds((Set<Integer>)value);
      }
      break;

    case BUCKET_IDS_TABLE:
      if (value == null) {
        unsetBucketIdsTable();
      } else {
        setBucketIdsTable((String)value);
      }
      break;

    case RETAIN_BUCKET_IDS:
      if (value == null) {
        unsetRetainBucketIds();
      } else {
        setRetainBucketIds((Boolean)value);
      }
      break;

    case METADATA_VERSION:
      if (value == null) {
        unsetMetadataVersion();
      } else {
        setMetadataVersion((Integer)value);
      }
      break;

    case SNAPSHOT_TRANSACTION_ID:
      if (value == null) {
        unsetSnapshotTransactionId();
      } else {
        setSnapshotTransactionId((String)value);
      }
      break;

    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case RESULT_SET_TYPE:
      return getResultSetType();

    case UPDATABLE:
      return isUpdatable();

    case HOLD_CURSORS_OVER_COMMIT:
      return isHoldCursorsOverCommit();

    case REQUIRE_AUTO_INC_COLS:
      return isRequireAutoIncCols();

    case AUTO_INC_COLUMNS:
      return getAutoIncColumns();

    case AUTO_INC_COLUMN_NAMES:
      return getAutoIncColumnNames();

    case BATCH_SIZE:
      return getBatchSize();

    case FETCH_REVERSE:
      return isFetchReverse();

    case LOB_CHUNK_SIZE:
      return getLobChunkSize();

    case MAX_ROWS:
      return getMaxRows();

    case MAX_FIELD_SIZE:
      return getMaxFieldSize();

    case TIMEOUT:
      return getTimeout();

    case CURSOR_NAME:
      return getCursorName();

    case POSSIBLE_DUPLICATE:
      return isPossibleDuplicate();

    case POOLABLE:
      return isPoolable();

    case DO_ESCAPE_PROCESSING:
      return isDoEscapeProcessing();

    case PENDING_TRANSACTION_ATTRS:
      return getPendingTransactionAttrs();

    case BUCKET_IDS:
      return getBucketIds();

    case BUCKET_IDS_TABLE:
      return getBucketIdsTable();

    case RETAIN_BUCKET_IDS:
      return isRetainBucketIds();

    case METADATA_VERSION:
      return getMetadataVersion();

    case SNAPSHOT_TRANSACTION_ID:
      return getSnapshotTransactionId();

    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case RESULT_SET_TYPE:
      return isSetResultSetType();
    case UPDATABLE:
      return isSetUpdatable();
    case HOLD_CURSORS_OVER_COMMIT:
      return isSetHoldCursorsOverCommit();
    case REQUIRE_AUTO_INC_COLS:
      return isSetRequireAutoIncCols();
    case AUTO_INC_COLUMNS:
      return isSetAutoIncColumns();
    case AUTO_INC_COLUMN_NAMES:
      return isSetAutoIncColumnNames();
    case BATCH_SIZE:
      return isSetBatchSize();
    case FETCH_REVERSE:
      return isSetFetchReverse();
    case LOB_CHUNK_SIZE:
      return isSetLobChunkSize();
    case MAX_ROWS:
      return isSetMaxRows();
    case MAX_FIELD_SIZE:
      return isSetMaxFieldSize();
    case TIMEOUT:
      return isSetTimeout();
    case CURSOR_NAME:
      return isSetCursorName();
    case POSSIBLE_DUPLICATE:
      return isSetPossibleDuplicate();
    case POOLABLE:
      return isSetPoolable();
    case DO_ESCAPE_PROCESSING:
      return isSetDoEscapeProcessing();
    case PENDING_TRANSACTION_ATTRS:
      return isSetPendingTransactionAttrs();
    case BUCKET_IDS:
      return isSetBucketIds();
    case BUCKET_IDS_TABLE:
      return isSetBucketIdsTable();
    case RETAIN_BUCKET_IDS:
      return isSetRetainBucketIds();
    case METADATA_VERSION:
      return isSetMetadataVersion();
    case SNAPSHOT_TRANSACTION_ID:
      return isSetSnapshotTransactionId();
    }
    throw new IllegalStateException();
  }

  @Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof StatementAttrs)
      return this.equals((StatementAttrs)that);
    return false;
  }

  public boolean equals(StatementAttrs that) {
    if (that == null)
      return false;

    boolean this_present_resultSetType = true && this.isSetResultSetType();
    boolean that_present_resultSetType = true && that.isSetResultSetType();
    if (this_present_resultSetType || that_present_resultSetType) {
      if (!(this_present_resultSetType && that_present_resultSetType))
        return false;
      if (this.resultSetType != that.resultSetType)
        return false;
    }

    boolean this_present_updatable = true && this.isSetUpdatable();
    boolean that_present_updatable = true && that.isSetUpdatable();
    if (this_present_updatable || that_present_updatable) {
      if (!(this_present_updatable && that_present_updatable))
        return false;
      if (this.updatable != that.updatable)
        return false;
    }

    boolean this_present_holdCursorsOverCommit = true && this.isSetHoldCursorsOverCommit();
    boolean that_present_holdCursorsOverCommit = true && that.isSetHoldCursorsOverCommit();
    if (this_present_holdCursorsOverCommit || that_present_holdCursorsOverCommit) {
      if (!(this_present_holdCursorsOverCommit && that_present_holdCursorsOverCommit))
        return false;
      if (this.holdCursorsOverCommit != that.holdCursorsOverCommit)
        return false;
    }

    boolean this_present_requireAutoIncCols = true && this.isSetRequireAutoIncCols();
    boolean that_present_requireAutoIncCols = true && that.isSetRequireAutoIncCols();
    if (this_present_requireAutoIncCols || that_present_requireAutoIncCols) {
      if (!(this_present_requireAutoIncCols && that_present_requireAutoIncCols))
        return false;
      if (this.requireAutoIncCols != that.requireAutoIncCols)
        return false;
    }

    boolean this_present_autoIncColumns = true && this.isSetAutoIncColumns();
    boolean that_present_autoIncColumns = true && that.isSetAutoIncColumns();
    if (this_present_autoIncColumns || that_present_autoIncColumns) {
      if (!(this_present_autoIncColumns && that_present_autoIncColumns))
        return false;
      if (!this.autoIncColumns.equals(that.autoIncColumns))
        return false;
    }

    boolean this_present_autoIncColumnNames = true && this.isSetAutoIncColumnNames();
    boolean that_present_autoIncColumnNames = true && that.isSetAutoIncColumnNames();
    if (this_present_autoIncColumnNames || that_present_autoIncColumnNames) {
      if (!(this_present_autoIncColumnNames && that_present_autoIncColumnNames))
        return false;
      if (!this.autoIncColumnNames.equals(that.autoIncColumnNames))
        return false;
    }

    boolean this_present_batchSize = true && this.isSetBatchSize();
    boolean that_present_batchSize = true && that.isSetBatchSize();
    if (this_present_batchSize || that_present_batchSize) {
      if (!(this_present_batchSize && that_present_batchSize))
        return false;
      if (this.batchSize != that.batchSize)
        return false;
    }

    boolean this_present_fetchReverse = true && this.isSetFetchReverse();
    boolean that_present_fetchReverse = true && that.isSetFetchReverse();
    if (this_present_fetchReverse || that_present_fetchReverse) {
      if (!(this_present_fetchReverse && that_present_fetchReverse))
        return false;
      if (this.fetchReverse != that.fetchReverse)
        return false;
    }

    boolean this_present_lobChunkSize = true && this.isSetLobChunkSize();
    boolean that_present_lobChunkSize = true && that.isSetLobChunkSize();
    if (this_present_lobChunkSize || that_present_lobChunkSize) {
      if (!(this_present_lobChunkSize && that_present_lobChunkSize))
        return false;
      if (this.lobChunkSize != that.lobChunkSize)
        return false;
    }

    boolean this_present_maxRows = true && this.isSetMaxRows();
    boolean that_present_maxRows = true && that.isSetMaxRows();
    if (this_present_maxRows || that_present_maxRows) {
      if (!(this_present_maxRows && that_present_maxRows))
        return false;
      if (this.maxRows != that.maxRows)
        return false;
    }

    boolean this_present_maxFieldSize = true && this.isSetMaxFieldSize();
    boolean that_present_maxFieldSize = true && that.isSetMaxFieldSize();
    if (this_present_maxFieldSize || that_present_maxFieldSize) {
      if (!(this_present_maxFieldSize && that_present_maxFieldSize))
        return false;
      if (this.maxFieldSize != that.maxFieldSize)
        return false;
    }

    boolean this_present_timeout = true && this.isSetTimeout();
    boolean that_present_timeout = true && that.isSetTimeout();
    if (this_present_timeout || that_present_timeout) {
      if (!(this_present_timeout && that_present_timeout))
        return false;
      if (this.timeout != that.timeout)
        return false;
    }

    boolean this_present_cursorName = true && this.isSetCursorName();
    boolean that_present_cursorName = true && that.isSetCursorName();
    if (this_present_cursorName || that_present_cursorName) {
      if (!(this_present_cursorName && that_present_cursorName))
        return false;
      if (!this.cursorName.equals(that.cursorName))
        return false;
    }

    boolean this_present_possibleDuplicate = true && this.isSetPossibleDuplicate();
    boolean that_present_possibleDuplicate = true && that.isSetPossibleDuplicate();
    if (this_present_possibleDuplicate || that_present_possibleDuplicate) {
      if (!(this_present_possibleDuplicate && that_present_possibleDuplicate))
        return false;
      if (this.possibleDuplicate != that.possibleDuplicate)
        return false;
    }

    boolean this_present_poolable = true && this.isSetPoolable();
    boolean that_present_poolable = true && that.isSetPoolable();
    if (this_present_poolable || that_present_poolable) {
      if (!(this_present_poolable && that_present_poolable))
        return false;
      if (this.poolable != that.poolable)
        return false;
    }

    boolean this_present_doEscapeProcessing = true && this.isSetDoEscapeProcessing();
    boolean that_present_doEscapeProcessing = true && that.isSetDoEscapeProcessing();
    if (this_present_doEscapeProcessing || that_present_doEscapeProcessing) {
      if (!(this_present_doEscapeProcessing && that_present_doEscapeProcessing))
        return false;
      if (this.doEscapeProcessing != that.doEscapeProcessing)
        return false;
    }

    boolean this_present_pendingTransactionAttrs = true && this.isSetPendingTransactionAttrs();
    boolean that_present_pendingTransactionAttrs = true && that.isSetPendingTransactionAttrs();
    if (this_present_pendingTransactionAttrs || that_present_pendingTransactionAttrs) {
      if (!(this_present_pendingTransactionAttrs && that_present_pendingTransactionAttrs))
        return false;
      if (!this.pendingTransactionAttrs.equals(that.pendingTransactionAttrs))
        return false;
    }

    boolean this_present_bucketIds = true && this.isSetBucketIds();
    boolean that_present_bucketIds = true && that.isSetBucketIds();
    if (this_present_bucketIds || that_present_bucketIds) {
      if (!(this_present_bucketIds && that_present_bucketIds))
        return false;
      if (!this.bucketIds.equals(that.bucketIds))
        return false;
    }

    boolean this_present_bucketIdsTable = true && this.isSetBucketIdsTable();
    boolean that_present_bucketIdsTable = true && that.isSetBucketIdsTable();
    if (this_present_bucketIdsTable || that_present_bucketIdsTable) {
      if (!(this_present_bucketIdsTable && that_present_bucketIdsTable))
        return false;
      if (!this.bucketIdsTable.equals(that.bucketIdsTable))
        return false;
    }

    boolean this_present_retainBucketIds = true && this.isSetRetainBucketIds();
    boolean that_present_retainBucketIds = true && that.isSetRetainBucketIds();
    if (this_present_retainBucketIds || that_present_retainBucketIds) {
      if (!(this_present_retainBucketIds && that_present_retainBucketIds))
        return false;
      if (this.retainBucketIds != that.retainBucketIds)
        return false;
    }

    boolean this_present_metadataVersion = true && this.isSetMetadataVersion();
    boolean that_present_metadataVersion = true && that.isSetMetadataVersion();
    if (this_present_metadataVersion || that_present_metadataVersion) {
      if (!(this_present_metadataVersion && that_present_metadataVersion))
        return false;
      if (this.metadataVersion != that.metadataVersion)
        return false;
    }

    boolean this_present_snapshotTransactionId = true && this.isSetSnapshotTransactionId();
    boolean that_present_snapshotTransactionId = true && that.isSetSnapshotTransactionId();
    if (this_present_snapshotTransactionId || that_present_snapshotTransactionId) {
      if (!(this_present_snapshotTransactionId && that_present_snapshotTransactionId))
        return false;
      if (!this.snapshotTransactionId.equals(that.snapshotTransactionId))
        return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    List<Object> list = new ArrayList<Object>();

    boolean present_resultSetType = true && (isSetResultSetType());
    list.add(present_resultSetType);
    if (present_resultSetType)
      list.add(resultSetType);

    boolean present_updatable = true && (isSetUpdatable());
    list.add(present_updatable);
    if (present_updatable)
      list.add(updatable);

    boolean present_holdCursorsOverCommit = true && (isSetHoldCursorsOverCommit());
    list.add(present_holdCursorsOverCommit);
    if (present_holdCursorsOverCommit)
      list.add(holdCursorsOverCommit);

    boolean present_requireAutoIncCols = true && (isSetRequireAutoIncCols());
    list.add(present_requireAutoIncCols);
    if (present_requireAutoIncCols)
      list.add(requireAutoIncCols);

    boolean present_autoIncColumns = true && (isSetAutoIncColumns());
    list.add(present_autoIncColumns);
    if (present_autoIncColumns)
      list.add(autoIncColumns);

    boolean present_autoIncColumnNames = true && (isSetAutoIncColumnNames());
    list.add(present_autoIncColumnNames);
    if (present_autoIncColumnNames)
      list.add(autoIncColumnNames);

    boolean present_batchSize = true && (isSetBatchSize());
    list.add(present_batchSize);
    if (present_batchSize)
      list.add(batchSize);

    boolean present_fetchReverse = true && (isSetFetchReverse());
    list.add(present_fetchReverse);
    if (present_fetchReverse)
      list.add(fetchReverse);

    boolean present_lobChunkSize = true && (isSetLobChunkSize());
    list.add(present_lobChunkSize);
    if (present_lobChunkSize)
      list.add(lobChunkSize);

    boolean present_maxRows = true && (isSetMaxRows());
    list.add(present_maxRows);
    if (present_maxRows)
      list.add(maxRows);

    boolean present_maxFieldSize = true && (isSetMaxFieldSize());
    list.add(present_maxFieldSize);
    if (present_maxFieldSize)
      list.add(maxFieldSize);

    boolean present_timeout = true && (isSetTimeout());
    list.add(present_timeout);
    if (present_timeout)
      list.add(timeout);

    boolean present_cursorName = true && (isSetCursorName());
    list.add(present_cursorName);
    if (present_cursorName)
      list.add(cursorName);

    boolean present_possibleDuplicate = true && (isSetPossibleDuplicate());
    list.add(present_possibleDuplicate);
    if (present_possibleDuplicate)
      list.add(possibleDuplicate);

    boolean present_poolable = true && (isSetPoolable());
    list.add(present_poolable);
    if (present_poolable)
      list.add(poolable);

    boolean present_doEscapeProcessing = true && (isSetDoEscapeProcessing());
    list.add(present_doEscapeProcessing);
    if (present_doEscapeProcessing)
      list.add(doEscapeProcessing);

    boolean present_pendingTransactionAttrs = true && (isSetPendingTransactionAttrs());
    list.add(present_pendingTransactionAttrs);
    if (present_pendingTransactionAttrs)
      list.add(pendingTransactionAttrs);

    boolean present_bucketIds = true && (isSetBucketIds());
    list.add(present_bucketIds);
    if (present_bucketIds)
      list.add(bucketIds);

    boolean present_bucketIdsTable = true && (isSetBucketIdsTable());
    list.add(present_bucketIdsTable);
    if (present_bucketIdsTable)
      list.add(bucketIdsTable);

    boolean present_retainBucketIds = true && (isSetRetainBucketIds());
    list.add(present_retainBucketIds);
    if (present_retainBucketIds)
      list.add(retainBucketIds);

    boolean present_metadataVersion = true && (isSetMetadataVersion());
    list.add(present_metadataVersion);
    if (present_metadataVersion)
      list.add(metadataVersion);

    boolean present_snapshotTransactionId = true && (isSetSnapshotTransactionId());
    list.add(present_snapshotTransactionId);
    if (present_snapshotTransactionId)
      list.add(snapshotTransactionId);

    return list.hashCode();
  }

  @Override
  public int compareTo(StatementAttrs other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;

    lastComparison = Boolean.valueOf(isSetResultSetType()).compareTo(other.isSetResultSetType());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetResultSetType()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.resultSetType, other.resultSetType);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetUpdatable()).compareTo(other.isSetUpdatable());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetUpdatable()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.updatable, other.updatable);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetHoldCursorsOverCommit()).compareTo(other.isSetHoldCursorsOverCommit());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetHoldCursorsOverCommit()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.holdCursorsOverCommit, other.holdCursorsOverCommit);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRequireAutoIncCols()).compareTo(other.isSetRequireAutoIncCols());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRequireAutoIncCols()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.requireAutoIncCols, other.requireAutoIncCols);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetAutoIncColumns()).compareTo(other.isSetAutoIncColumns());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetAutoIncColumns()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.autoIncColumns, other.autoIncColumns);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetAutoIncColumnNames()).compareTo(other.isSetAutoIncColumnNames());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetAutoIncColumnNames()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.autoIncColumnNames, other.autoIncColumnNames);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetBatchSize()).compareTo(other.isSetBatchSize());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetBatchSize()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.batchSize, other.batchSize);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetFetchReverse()).compareTo(other.isSetFetchReverse());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetFetchReverse()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.fetchReverse, other.fetchReverse);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetLobChunkSize()).compareTo(other.isSetLobChunkSize());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetLobChunkSize()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.lobChunkSize, other.lobChunkSize);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMaxRows()).compareTo(other.isSetMaxRows());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMaxRows()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.maxRows, other.maxRows);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMaxFieldSize()).compareTo(other.isSetMaxFieldSize());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMaxFieldSize()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.maxFieldSize, other.maxFieldSize);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetTimeout()).compareTo(other.isSetTimeout());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetTimeout()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.timeout, other.timeout);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCursorName()).compareTo(other.isSetCursorName());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCursorName()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.cursorName, other.cursorName);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetPossibleDuplicate()).compareTo(other.isSetPossibleDuplicate());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetPossibleDuplicate()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.possibleDuplicate, other.possibleDuplicate);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetPoolable()).compareTo(other.isSetPoolable());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetPoolable()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.poolable, other.poolable);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetDoEscapeProcessing()).compareTo(other.isSetDoEscapeProcessing());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetDoEscapeProcessing()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.doEscapeProcessing, other.doEscapeProcessing);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetPendingTransactionAttrs()).compareTo(other.isSetPendingTransactionAttrs());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetPendingTransactionAttrs()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.pendingTransactionAttrs, other.pendingTransactionAttrs);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetBucketIds()).compareTo(other.isSetBucketIds());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetBucketIds()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.bucketIds, other.bucketIds);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetBucketIdsTable()).compareTo(other.isSetBucketIdsTable());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetBucketIdsTable()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.bucketIdsTable, other.bucketIdsTable);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRetainBucketIds()).compareTo(other.isSetRetainBucketIds());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRetainBucketIds()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.retainBucketIds, other.retainBucketIds);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMetadataVersion()).compareTo(other.isSetMetadataVersion());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMetadataVersion()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.metadataVersion, other.metadataVersion);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetSnapshotTransactionId()).compareTo(other.isSetSnapshotTransactionId());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetSnapshotTransactionId()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.snapshotTransactionId, other.snapshotTransactionId);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }

  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
  }

  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("StatementAttrs(");
    boolean first = true;

    if (isSetResultSetType()) {
      sb.append("resultSetType:");
      sb.append(this.resultSetType);
      first = false;
    }
    if (isSetUpdatable()) {
      if (!first) sb.append(", ");
      sb.append("updatable:");
      sb.append(this.updatable);
      first = false;
    }
    if (isSetHoldCursorsOverCommit()) {
      if (!first) sb.append(", ");
      sb.append("holdCursorsOverCommit:");
      sb.append(this.holdCursorsOverCommit);
      first = false;
    }
    if (isSetRequireAutoIncCols()) {
      if (!first) sb.append(", ");
      sb.append("requireAutoIncCols:");
      sb.append(this.requireAutoIncCols);
      first = false;
    }
    if (isSetAutoIncColumns()) {
      if (!first) sb.append(", ");
      sb.append("autoIncColumns:");
      if (this.autoIncColumns == null) {
        sb.append("null");
      } else {
        sb.append(this.autoIncColumns);
      }
      first = false;
    }
    if (isSetAutoIncColumnNames()) {
      if (!first) sb.append(", ");
      sb.append("autoIncColumnNames:");
      if (this.autoIncColumnNames == null) {
        sb.append("null");
      } else {
        sb.append(this.autoIncColumnNames);
      }
      first = false;
    }
    if (isSetBatchSize()) {
      if (!first) sb.append(", ");
      sb.append("batchSize:");
      sb.append(this.batchSize);
      first = false;
    }
    if (isSetFetchReverse()) {
      if (!first) sb.append(", ");
      sb.append("fetchReverse:");
      sb.append(this.fetchReverse);
      first = false;
    }
    if (isSetLobChunkSize()) {
      if (!first) sb.append(", ");
      sb.append("lobChunkSize:");
      sb.append(this.lobChunkSize);
      first = false;
    }
    if (isSetMaxRows()) {
      if (!first) sb.append(", ");
      sb.append("maxRows:");
      sb.append(this.maxRows);
      first = false;
    }
    if (isSetMaxFieldSize()) {
      if (!first) sb.append(", ");
      sb.append("maxFieldSize:");
      sb.append(this.maxFieldSize);
      first = false;
    }
    if (isSetTimeout()) {
      if (!first) sb.append(", ");
      sb.append("timeout:");
      sb.append(this.timeout);
      first = false;
    }
    if (isSetCursorName()) {
      if (!first) sb.append(", ");
      sb.append("cursorName:");
      if (this.cursorName == null) {
        sb.append("null");
      } else {
        sb.append(this.cursorName);
      }
      first = false;
    }
    if (isSetPossibleDuplicate()) {
      if (!first) sb.append(", ");
      sb.append("possibleDuplicate:");
      sb.append(this.possibleDuplicate);
      first = false;
    }
    if (isSetPoolable()) {
      if (!first) sb.append(", ");
      sb.append("poolable:");
      sb.append(this.poolable);
      first = false;
    }
    if (isSetDoEscapeProcessing()) {
      if (!first) sb.append(", ");
      sb.append("doEscapeProcessing:");
      sb.append(this.doEscapeProcessing);
      first = false;
    }
    if (isSetPendingTransactionAttrs()) {
      if (!first) sb.append(", ");
      sb.append("pendingTransactionAttrs:");
      if (this.pendingTransactionAttrs == null) {
        sb.append("null");
      } else {
        sb.append(this.pendingTransactionAttrs);
      }
      first = false;
    }
    if (isSetBucketIds()) {
      if (!first) sb.append(", ");
      sb.append("bucketIds:");
      if (this.bucketIds == null) {
        sb.append("null");
      } else {
        sb.append(this.bucketIds);
      }
      first = false;
    }
    if (isSetBucketIdsTable()) {
      if (!first) sb.append(", ");
      sb.append("bucketIdsTable:");
      if (this.bucketIdsTable == null) {
        sb.append("null");
      } else {
        sb.append(this.bucketIdsTable);
      }
      first = false;
    }
    if (isSetRetainBucketIds()) {
      if (!first) sb.append(", ");
      sb.append("retainBucketIds:");
      sb.append(this.retainBucketIds);
      first = false;
    }
    if (isSetMetadataVersion()) {
      if (!first) sb.append(", ");
      sb.append("metadataVersion:");
      sb.append(this.metadataVersion);
      first = false;
    }
    if (isSetSnapshotTransactionId()) {
      if (!first) sb.append(", ");
      sb.append("snapshotTransactionId:");
      if (this.snapshotTransactionId == null) {
        sb.append("null");
      } else {
        sb.append(this.snapshotTransactionId);
      }
      first = false;
    }
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws org.apache.thrift.TException {
    // check for required fields
    // check for sub-struct validity
  }

  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
    try {
      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
    try {
      // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
      __isset_bitfield = 0;
      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private static class StatementAttrsStandardSchemeFactory implements SchemeFactory {
    public StatementAttrsStandardScheme getScheme() {
      return new StatementAttrsStandardScheme();
    }
  }

  private static class StatementAttrsStandardScheme extends StandardScheme<StatementAttrs> {

    public void read(org.apache.thrift.protocol.TProtocol iprot, StatementAttrs struct) throws org.apache.thrift.TException {
      org.apache.thrift.protocol.TField schemeField;
      iprot.readStructBegin();
      while (true)
      {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (schemeField.id) {
          case 1: // RESULT_SET_TYPE
            if (schemeField.type == org.apache.thrift.protocol.TType.BYTE) {
              struct.resultSetType = iprot.readByte();
              struct.setResultSetTypeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 2: // UPDATABLE
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.updatable = iprot.readBool();
              struct.setUpdatableIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 3: // HOLD_CURSORS_OVER_COMMIT
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.holdCursorsOverCommit = iprot.readBool();
              struct.setHoldCursorsOverCommitIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 4: // REQUIRE_AUTO_INC_COLS
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.requireAutoIncCols = iprot.readBool();
              struct.setRequireAutoIncColsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 5: // AUTO_INC_COLUMNS
            if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list128 = iprot.readListBegin();
                struct.autoIncColumns = new ArrayList<Integer>(_list128.size);
                int _elem129;
                for (int _i130 = 0; _i130 < _list128.size; ++_i130)
                {
                  _elem129 = iprot.readI32();
                  struct.autoIncColumns.add(_elem129);
                }
                iprot.readListEnd();
              }
              struct.setAutoIncColumnsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 6: // AUTO_INC_COLUMN_NAMES
            if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list131 = iprot.readListBegin();
                struct.autoIncColumnNames = new ArrayList<String>(_list131.size);
                String _elem132;
                for (int _i133 = 0; _i133 < _list131.size; ++_i133)
                {
                  _elem132 = iprot.readString();
                  struct.autoIncColumnNames.add(_elem132);
                }
                iprot.readListEnd();
              }
              struct.setAutoIncColumnNamesIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 7: // BATCH_SIZE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.batchSize = iprot.readI32();
              struct.setBatchSizeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 8: // FETCH_REVERSE
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.fetchReverse = iprot.readBool();
              struct.setFetchReverseIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 9: // LOB_CHUNK_SIZE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.lobChunkSize = iprot.readI32();
              struct.setLobChunkSizeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 10: // MAX_ROWS
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.maxRows = iprot.readI32();
              struct.setMaxRowsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 11: // MAX_FIELD_SIZE
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.maxFieldSize = iprot.readI32();
              struct.setMaxFieldSizeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 12: // TIMEOUT
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.timeout = iprot.readI32();
              struct.setTimeoutIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 13: // CURSOR_NAME
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.cursorName = iprot.readString();
              struct.setCursorNameIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 14: // POSSIBLE_DUPLICATE
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.possibleDuplicate = iprot.readBool();
              struct.setPossibleDuplicateIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 15: // POOLABLE
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.poolable = iprot.readBool();
              struct.setPoolableIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 16: // DO_ESCAPE_PROCESSING
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.doEscapeProcessing = iprot.readBool();
              struct.setDoEscapeProcessingIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 17: // PENDING_TRANSACTION_ATTRS
            if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
              {
                org.apache.thrift.protocol.TMap _map134 = iprot.readMapBegin();
                struct.pendingTransactionAttrs = new HashMap<TransactionAttribute,Boolean>(2*_map134.size);
                TransactionAttribute _key135;
                boolean _val136;
                for (int _i137 = 0; _i137 < _map134.size; ++_i137)
                {
                  _key135 = io.snappydata.thrift.TransactionAttribute.findByValue(iprot.readI32());
                  _val136 = iprot.readBool();
                  struct.pendingTransactionAttrs.put(_key135, _val136);
                }
                iprot.readMapEnd();
              }
              struct.setPendingTransactionAttrsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 18: // BUCKET_IDS
            if (schemeField.type == org.apache.thrift.protocol.TType.SET) {
              {
                org.apache.thrift.protocol.TSet _set138 = iprot.readSetBegin();
                struct.bucketIds = new HashSet<Integer>(2*_set138.size);
                int _elem139;
                for (int _i140 = 0; _i140 < _set138.size; ++_i140)
                {
                  _elem139 = iprot.readI32();
                  struct.bucketIds.add(_elem139);
                }
                iprot.readSetEnd();
              }
              struct.setBucketIdsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 19: // BUCKET_IDS_TABLE
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.bucketIdsTable = iprot.readString();
              struct.setBucketIdsTableIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 20: // RETAIN_BUCKET_IDS
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.retainBucketIds = iprot.readBool();
              struct.setRetainBucketIdsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 21: // METADATA_VERSION
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.metadataVersion = iprot.readI32();
              struct.setMetadataVersionIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 22: // SNAPSHOT_TRANSACTION_ID
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.snapshotTransactionId = iprot.readString();
              struct.setSnapshotTransactionIdIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      struct.validate();
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot, StatementAttrs struct) throws org.apache.thrift.TException {
      struct.validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (struct.isSetResultSetType()) {
        oprot.writeFieldBegin(RESULT_SET_TYPE_FIELD_DESC);
        oprot.writeByte(struct.resultSetType);
        oprot.writeFieldEnd();
      }
      if (struct.isSetUpdatable()) {
        oprot.writeFieldBegin(UPDATABLE_FIELD_DESC);
        oprot.writeBool(struct.updatable);
        oprot.writeFieldEnd();
      }
      if (struct.isSetHoldCursorsOverCommit()) {
        oprot.writeFieldBegin(HOLD_CURSORS_OVER_COMMIT_FIELD_DESC);
        oprot.writeBool(struct.holdCursorsOverCommit);
        oprot.writeFieldEnd();
      }
      if (struct.isSetRequireAutoIncCols()) {
        oprot.writeFieldBegin(REQUIRE_AUTO_INC_COLS_FIELD_DESC);
        oprot.writeBool(struct.requireAutoIncCols);
        oprot.writeFieldEnd();
      }
      if (struct.autoIncColumns != null) {
        if (struct.isSetAutoIncColumns()) {
          oprot.writeFieldBegin(AUTO_INC_COLUMNS_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I32, struct.autoIncColumns.size()));
            for (int _iter141 : struct.autoIncColumns)
            {
              oprot.writeI32(_iter141);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
      }
      if (struct.autoIncColumnNames != null) {
        if (struct.isSetAutoIncColumnNames()) {
          oprot.writeFieldBegin(AUTO_INC_COLUMN_NAMES_FIELD_DESC);
          {
            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, struct.autoIncColumnNames.size()));
            for (String _iter142 : struct.autoIncColumnNames)
            {
              oprot.writeString(_iter142);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
      }
      if (struct.isSetBatchSize()) {
        oprot.writeFieldBegin(BATCH_SIZE_FIELD_DESC);
        oprot.writeI32(struct.batchSize);
        oprot.writeFieldEnd();
      }
      if (struct.isSetFetchReverse()) {
        oprot.writeFieldBegin(FETCH_REVERSE_FIELD_DESC);
        oprot.writeBool(struct.fetchReverse);
        oprot.writeFieldEnd();
      }
      if (struct.isSetLobChunkSize()) {
        oprot.writeFieldBegin(LOB_CHUNK_SIZE_FIELD_DESC);
        oprot.writeI32(struct.lobChunkSize);
        oprot.writeFieldEnd();
      }
      if (struct.isSetMaxRows()) {
        oprot.writeFieldBegin(MAX_ROWS_FIELD_DESC);
        oprot.writeI32(struct.maxRows);
        oprot.writeFieldEnd();
      }
      if (struct.isSetMaxFieldSize()) {
        oprot.writeFieldBegin(MAX_FIELD_SIZE_FIELD_DESC);
        oprot.writeI32(struct.maxFieldSize);
        oprot.writeFieldEnd();
      }
      if (struct.isSetTimeout()) {
        oprot.writeFieldBegin(TIMEOUT_FIELD_DESC);
        oprot.writeI32(struct.timeout);
        oprot.writeFieldEnd();
      }
      if (struct.cursorName != null) {
        if (struct.isSetCursorName()) {
          oprot.writeFieldBegin(CURSOR_NAME_FIELD_DESC);
          oprot.writeString(struct.cursorName);
          oprot.writeFieldEnd();
        }
      }
      if (struct.isSetPossibleDuplicate()) {
        oprot.writeFieldBegin(POSSIBLE_DUPLICATE_FIELD_DESC);
        oprot.writeBool(struct.possibleDuplicate);
        oprot.writeFieldEnd();
      }
      if (struct.isSetPoolable()) {
        oprot.writeFieldBegin(POOLABLE_FIELD_DESC);
        oprot.writeBool(struct.poolable);
        oprot.writeFieldEnd();
      }
      if (struct.isSetDoEscapeProcessing()) {
        oprot.writeFieldBegin(DO_ESCAPE_PROCESSING_FIELD_DESC);
        oprot.writeBool(struct.doEscapeProcessing);
        oprot.writeFieldEnd();
      }
      if (struct.pendingTransactionAttrs != null) {
        if (struct.isSetPendingTransactionAttrs()) {
          oprot.writeFieldBegin(PENDING_TRANSACTION_ATTRS_FIELD_DESC);
          {
            oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.I32, org.apache.thrift.protocol.TType.BOOL, struct.pendingTransactionAttrs.size()));
            for (Map.Entry<TransactionAttribute, Boolean> _iter143 : struct.pendingTransactionAttrs.entrySet())
            {
              oprot.writeI32(_iter143.getKey().getValue());
              oprot.writeBool(_iter143.getValue());
            }
            oprot.writeMapEnd();
          }
          oprot.writeFieldEnd();
        }
      }
      if (struct.bucketIds != null) {
        if (struct.isSetBucketIds()) {
          oprot.writeFieldBegin(BUCKET_IDS_FIELD_DESC);
          {
            oprot.writeSetBegin(new org.apache.thrift.protocol.TSet(org.apache.thrift.protocol.TType.I32, struct.bucketIds.size()));
            for (int _iter144 : struct.bucketIds)
            {
              oprot.writeI32(_iter144);
            }
            oprot.writeSetEnd();
          }
          oprot.writeFieldEnd();
        }
      }
      if (struct.bucketIdsTable != null) {
        if (struct.isSetBucketIdsTable()) {
          oprot.writeFieldBegin(BUCKET_IDS_TABLE_FIELD_DESC);
          oprot.writeString(struct.bucketIdsTable);
          oprot.writeFieldEnd();
        }
      }
      if (struct.isSetRetainBucketIds()) {
        oprot.writeFieldBegin(RETAIN_BUCKET_IDS_FIELD_DESC);
        oprot.writeBool(struct.retainBucketIds);
        oprot.writeFieldEnd();
      }
      if (struct.isSetMetadataVersion()) {
        oprot.writeFieldBegin(METADATA_VERSION_FIELD_DESC);
        oprot.writeI32(struct.metadataVersion);
        oprot.writeFieldEnd();
      }
      if (struct.snapshotTransactionId != null) {
        if (struct.isSetSnapshotTransactionId()) {
          oprot.writeFieldBegin(SNAPSHOT_TRANSACTION_ID_FIELD_DESC);
          oprot.writeString(struct.snapshotTransactionId);
          oprot.writeFieldEnd();
        }
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

  }

  private static class StatementAttrsTupleSchemeFactory implements SchemeFactory {
    public StatementAttrsTupleScheme getScheme() {
      return new StatementAttrsTupleScheme();
    }
  }

  private static class StatementAttrsTupleScheme extends TupleScheme<StatementAttrs> {

    @Override
    public void write(org.apache.thrift.protocol.TProtocol prot, StatementAttrs struct) throws org.apache.thrift.TException {
      TTupleProtocol oprot = (TTupleProtocol) prot;
      BitSet optionals = new BitSet();
      if (struct.isSetResultSetType()) {
        optionals.set(0);
      }
      if (struct.isSetUpdatable()) {
        optionals.set(1);
      }
      if (struct.isSetHoldCursorsOverCommit()) {
        optionals.set(2);
      }
      if (struct.isSetRequireAutoIncCols()) {
        optionals.set(3);
      }
      if (struct.isSetAutoIncColumns()) {
        optionals.set(4);
      }
      if (struct.isSetAutoIncColumnNames()) {
        optionals.set(5);
      }
      if (struct.isSetBatchSize()) {
        optionals.set(6);
      }
      if (struct.isSetFetchReverse()) {
        optionals.set(7);
      }
      if (struct.isSetLobChunkSize()) {
        optionals.set(8);
      }
      if (struct.isSetMaxRows()) {
        optionals.set(9);
      }
      if (struct.isSetMaxFieldSize()) {
        optionals.set(10);
      }
      if (struct.isSetTimeout()) {
        optionals.set(11);
      }
      if (struct.isSetCursorName()) {
        optionals.set(12);
      }
      if (struct.isSetPossibleDuplicate()) {
        optionals.set(13);
      }
      if (struct.isSetPoolable()) {
        optionals.set(14);
      }
      if (struct.isSetDoEscapeProcessing()) {
        optionals.set(15);
      }
      if (struct.isSetPendingTransactionAttrs()) {
        optionals.set(16);
      }
      if (struct.isSetBucketIds()) {
        optionals.set(17);
      }
      if (struct.isSetBucketIdsTable()) {
        optionals.set(18);
      }
      if (struct.isSetRetainBucketIds()) {
        optionals.set(19);
      }
      if (struct.isSetMetadataVersion()) {
        optionals.set(20);
      }
      if (struct.isSetSnapshotTransactionId()) {
        optionals.set(21);
      }
      oprot.writeBitSet(optionals, 22);
      if (struct.isSetResultSetType()) {
        oprot.writeByte(struct.resultSetType);
      }
      if (struct.isSetUpdatable()) {
        oprot.writeBool(struct.updatable);
      }
      if (struct.isSetHoldCursorsOverCommit()) {
        oprot.writeBool(struct.holdCursorsOverCommit);
      }
      if (struct.isSetRequireAutoIncCols()) {
        oprot.writeBool(struct.requireAutoIncCols);
      }
      if (struct.isSetAutoIncColumns()) {
        {
          oprot.writeI32(struct.autoIncColumns.size());
          for (int _iter145 : struct.autoIncColumns)
          {
            oprot.writeI32(_iter145);
          }
        }
      }
      if (struct.isSetAutoIncColumnNames()) {
        {
          oprot.writeI32(struct.autoIncColumnNames.size());
          for (String _iter146 : struct.autoIncColumnNames)
          {
            oprot.writeString(_iter146);
          }
        }
      }
      if (struct.isSetBatchSize()) {
        oprot.writeI32(struct.batchSize);
      }
      if (struct.isSetFetchReverse()) {
        oprot.writeBool(struct.fetchReverse);
      }
      if (struct.isSetLobChunkSize()) {
        oprot.writeI32(struct.lobChunkSize);
      }
      if (struct.isSetMaxRows()) {
        oprot.writeI32(struct.maxRows);
      }
      if (struct.isSetMaxFieldSize()) {
        oprot.writeI32(struct.maxFieldSize);
      }
      if (struct.isSetTimeout()) {
        oprot.writeI32(struct.timeout);
      }
      if (struct.isSetCursorName()) {
        oprot.writeString(struct.cursorName);
      }
      if (struct.isSetPossibleDuplicate()) {
        oprot.writeBool(struct.possibleDuplicate);
      }
      if (struct.isSetPoolable()) {
        oprot.writeBool(struct.poolable);
      }
      if (struct.isSetDoEscapeProcessing()) {
        oprot.writeBool(struct.doEscapeProcessing);
      }
      if (struct.isSetPendingTransactionAttrs()) {
        {
          oprot.writeI32(struct.pendingTransactionAttrs.size());
          for (Map.Entry<TransactionAttribute, Boolean> _iter147 : struct.pendingTransactionAttrs.entrySet())
          {
            oprot.writeI32(_iter147.getKey().getValue());
            oprot.writeBool(_iter147.getValue());
          }
        }
      }
      if (struct.isSetBucketIds()) {
        {
          oprot.writeI32(struct.bucketIds.size());
          for (int _iter148 : struct.bucketIds)
          {
            oprot.writeI32(_iter148);
          }
        }
      }
      if (struct.isSetBucketIdsTable()) {
        oprot.writeString(struct.bucketIdsTable);
      }
      if (struct.isSetRetainBucketIds()) {
        oprot.writeBool(struct.retainBucketIds);
      }
      if (struct.isSetMetadataVersion()) {
        oprot.writeI32(struct.metadataVersion);
      }
      if (struct.isSetSnapshotTransactionId()) {
        oprot.writeString(struct.snapshotTransactionId);
      }
    }

    @Override
    public void read(org.apache.thrift.protocol.TProtocol prot, StatementAttrs struct) throws org.apache.thrift.TException {
      TTupleProtocol iprot = (TTupleProtocol) prot;
      BitSet incoming = iprot.readBitSet(22);
      if (incoming.get(0)) {
        struct.resultSetType = iprot.readByte();
        struct.setResultSetTypeIsSet(true);
      }
      if (incoming.get(1)) {
        struct.updatable = iprot.readBool();
        struct.setUpdatableIsSet(true);
      }
      if (incoming.get(2)) {
        struct.holdCursorsOverCommit = iprot.readBool();
        struct.setHoldCursorsOverCommitIsSet(true);
      }
      if (incoming.get(3)) {
        struct.requireAutoIncCols = iprot.readBool();
        struct.setRequireAutoIncColsIsSet(true);
      }
      if (incoming.get(4)) {
        {
          org.apache.thrift.protocol.TList _list149 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I32, iprot.readI32());
          struct.autoIncColumns = new ArrayList<Integer>(_list149.size);
          int _elem150;
          for (int _i151 = 0; _i151 < _list149.size; ++_i151)
          {
            _elem150 = iprot.readI32();
            struct.autoIncColumns.add(_elem150);
          }
        }
        struct.setAutoIncColumnsIsSet(true);
      }
      if (incoming.get(5)) {
        {
          org.apache.thrift.protocol.TList _list152 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.STRING, iprot.readI32());
          struct.autoIncColumnNames = new ArrayList<String>(_list152.size);
          String _elem153;
          for (int _i154 = 0; _i154 < _list152.size; ++_i154)
          {
            _elem153 = iprot.readString();
            struct.autoIncColumnNames.add(_elem153);
          }
        }
        struct.setAutoIncColumnNamesIsSet(true);
      }
      if (incoming.get(6)) {
        struct.batchSize = iprot.readI32();
        struct.setBatchSizeIsSet(true);
      }
      if (incoming.get(7)) {
        struct.fetchReverse = iprot.readBool();
        struct.setFetchReverseIsSet(true);
      }
      if (incoming.get(8)) {
        struct.lobChunkSize = iprot.readI32();
        struct.setLobChunkSizeIsSet(true);
      }
      if (incoming.get(9)) {
        struct.maxRows = iprot.readI32();
        struct.setMaxRowsIsSet(true);
      }
      if (incoming.get(10)) {
        struct.maxFieldSize = iprot.readI32();
        struct.setMaxFieldSizeIsSet(true);
      }
      if (incoming.get(11)) {
        struct.timeout = iprot.readI32();
        struct.setTimeoutIsSet(true);
      }
      if (incoming.get(12)) {
        struct.cursorName = iprot.readString();
        struct.setCursorNameIsSet(true);
      }
      if (incoming.get(13)) {
        struct.possibleDuplicate = iprot.readBool();
        struct.setPossibleDuplicateIsSet(true);
      }
      if (incoming.get(14)) {
        struct.poolable = iprot.readBool();
        struct.setPoolableIsSet(true);
      }
      if (incoming.get(15)) {
        struct.doEscapeProcessing = iprot.readBool();
        struct.setDoEscapeProcessingIsSet(true);
      }
      if (incoming.get(16)) {
        {
          org.apache.thrift.protocol.TMap _map155 = new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.I32, org.apache.thrift.protocol.TType.BOOL, iprot.readI32());
          struct.pendingTransactionAttrs = new HashMap<TransactionAttribute,Boolean>(2*_map155.size);
          TransactionAttribute _key156;
          boolean _val157;
          for (int _i158 = 0; _i158 < _map155.size; ++_i158)
          {
            _key156 = io.snappydata.thrift.TransactionAttribute.findByValue(iprot.readI32());
            _val157 = iprot.readBool();
            struct.pendingTransactionAttrs.put(_key156, _val157);
          }
        }
        struct.setPendingTransactionAttrsIsSet(true);
      }
      if (incoming.get(17)) {
        {
          org.apache.thrift.protocol.TSet _set159 = new org.apache.thrift.protocol.TSet(org.apache.thrift.protocol.TType.I32, iprot.readI32());
          struct.bucketIds = new HashSet<Integer>(2*_set159.size);
          int _elem160;
          for (int _i161 = 0; _i161 < _set159.size; ++_i161)
          {
            _elem160 = iprot.readI32();
            struct.bucketIds.add(_elem160);
          }
        }
        struct.setBucketIdsIsSet(true);
      }
      if (incoming.get(18)) {
        struct.bucketIdsTable = iprot.readString();
        struct.setBucketIdsTableIsSet(true);
      }
      if (incoming.get(19)) {
        struct.retainBucketIds = iprot.readBool();
        struct.setRetainBucketIdsIsSet(true);
      }
      if (incoming.get(20)) {
        struct.metadataVersion = iprot.readI32();
        struct.setMetadataVersionIsSet(true);
      }
      if (incoming.get(21)) {
        struct.snapshotTransactionId = iprot.readString();
        struct.setSnapshotTransactionIdIsSet(true);
      }
    }
  }

}

