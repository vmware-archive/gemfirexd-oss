/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

/*
 * Changes for GemFireXD distributed data platform.
 *
 * Portions Copyright (c) 2010-2015 Pivotal Software, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License. You
 * may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License. See accompanying
 * LICENSE file.
 */

#ifndef GFXD_STRUCT_COLUMNVALUE_H
#define GFXD_STRUCT_COLUMNVALUE_H


extern "C"
{
#include <string.h>
}

#include "gfxd_types.h"

#include "gfxd_struct_FieldDescriptor.h"
#include "gfxd_struct_Decimal.h"
#include "gfxd_struct_Timestamp.h"
#include "gfxd_struct_FieldValue.h"
#include "gfxd_struct_PDXNode.h"
#include "gfxd_struct_PDXObject.h"
#include "gfxd_struct_PDXSchemaNode.h"
#include "gfxd_struct_PDXSchema.h"
#include "gfxd_struct_JSONField.h"
#include "gfxd_struct_JSONNode.h"
#include "gfxd_struct_JSONObject.h"
#include "gfxd_struct_BlobChunk.h"
#include "gfxd_struct_ClobChunk.h"
#include "gfxd_struct_ServiceMetaData.h"
#include "gfxd_struct_ServiceMetaDataArgs.h"
#include "gfxd_struct_OpenConnectionArgs.h"
#include "gfxd_struct_ConnectionProperties.h"
#include "gfxd_struct_HostAddress.h"
#include "gfxd_struct_GFXDExceptionData.h"
#include "gfxd_struct_StatementAttrs.h"
#include "gfxd_struct_DateTime.h"

namespace com { namespace pivotal { namespace gemfirexd { namespace thrift {

class ColumnValue
{
  union
  {
    bool bool_val;
    int8_t byte_val;
    int16_t i16_val;
    int32_t i32_val;
    int64_t i64_val;
    float float_val;
    double double_val;
    std::string* string_binary_java_val;
    Decimal* decimal_val;
    int64_t date_time_epoch_val;
    struct __ts {
      int64_t epochTime;
      int32_t nanos;

      bool operator==(const __ts other) const {
        return epochTime == other.epochTime && nanos == other.nanos;
      }
    } timestamp_val;
    BlobChunk* blob_val;
    ClobChunk* clob_val;
    bool null_val;
    PDXObject* pdx_val;
    JSONObject* json_val;
  } m_uval;

  GFXDType::type m_type;

public:

  static const char* ascii_fingerprint; // = "6BF6A87FFEB79DA83293FCF6CE0D5BAD";
  static const uint8_t binary_fingerprint[16]; // = {0x6B,0xF6,0xA8,0x7F,0xFE,0xB7,0x9D,0xA8,0x32,0x93,0xFC,0xF6,0xCE,0x0D,0x5B,0xAD};

  ColumnValue() : m_type(GFXDType::OTHER)
  {
  }

  void copyFields(const ColumnValue& other);

  void clearValue() throw();

  inline ColumnValue(const ColumnValue& other) {
    if (other.m_type == GFXDType::OTHER) {
      m_type = GFXDType::OTHER;
      return;
    }
    copyFields(other);
  }

  inline ColumnValue& operator=(const ColumnValue& other) {
    if (other.m_type == GFXDType::OTHER) {
      if (m_type == GFXDType::OTHER) {
        return *this;
      }
      m_type = GFXDType::OTHER;
      return *this;
    }
    clearValue();
    copyFields(other);
    return *this;
  }

  inline ~ColumnValue() throw() {
    clearValue();
  }

  inline GFXDType::type getType() const throw () {
    return m_type;
  }

  inline void setType(const GFXDType::type type) throw () {
    m_type = type;
  }

  inline bool isSetBool() const throw () {
    return (m_type == GFXDType::BOOLEAN);
  }

  inline bool getBool() const throw () {
    return m_uval.bool_val;
  }

  inline void setBool(const bool val) {
    clearValue();
    m_uval.bool_val = val;
    m_type = GFXDType::BOOLEAN;
  }

  inline bool isSetByte() const throw () {
    return (m_type == GFXDType::TINYINT);
  }

  inline int8_t getByte() const throw () {
    return m_uval.byte_val;
  }

  inline void setByte(const int8_t val) {
    clearValue();
    m_uval.byte_val = val;
    m_type = GFXDType::TINYINT;
  }

  inline bool isSetI16() const throw () {
    return (m_type == GFXDType::SMALLINT);
  }

  inline int16_t getI16() const throw () {
    return m_uval.i16_val;
  }

  inline void setI16(const int16_t val) {
    clearValue();
    m_uval.i16_val = val;
    m_type = GFXDType::SMALLINT;
  }

  inline bool isSetI32() const throw () {
    return (m_type == GFXDType::INTEGER);
  }

  inline int32_t getI32() const throw () {
    return m_uval.i32_val;
  }

  inline void setI32(const int32_t val) {
    clearValue();
    m_uval.i32_val = val;
    m_type = GFXDType::INTEGER;
  }

  inline bool isSetI64() const throw () {
    return (m_type == GFXDType::BIGINT);
  }

  inline int64_t getI64() const throw () {
    return m_uval.i64_val;
  }

  inline void setI64(const int64_t val) {
    clearValue();
    m_uval.i64_val = val;
    m_type = GFXDType::BIGINT;
  }

  inline bool isSetFloat() const throw () {
    return (m_type == GFXDType::FLOAT);
  }

  inline float getFloat()  const throw (){
    return m_uval.float_val;
  }

  inline void setFloat(const float val) {
    clearValue();
    m_uval.float_val = val;
    m_type = GFXDType::FLOAT;
  }

  inline bool isSetDouble() const throw () {
    return (m_type == GFXDType::DOUBLE);
  }

  inline double getDouble() const throw () {
    return m_uval.double_val;
  }

  inline void setDouble(const double val) {
    clearValue();
    m_uval.double_val = val;
    m_type = GFXDType::DOUBLE;
  }

  inline bool isSetString() const throw () {
    return (m_type == GFXDType::VARCHAR);
  }

  inline std::string* getString() const throw () {
    return m_uval.string_binary_java_val;
  }

  inline void setString(const std::string& val) {
    if (m_type & (GFXDType::VARCHAR
        | GFXDType::BINARY
        | GFXDType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(val);
    }
    else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(val);
    }
    m_type = GFXDType::VARCHAR;
  }

  inline void setString(const char* val) {
    if (m_type & (GFXDType::VARCHAR
        | GFXDType::BINARY
        | GFXDType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(val);
    }
    else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(val);
    }
    m_type = GFXDType::VARCHAR;
  }

  // TODO: PERF: we could change thrift impl to carry through char* instead
  // of copying to std::string for cases where execute is going to be fired
  // immediately after setting the parameters. Same for setBinary.
  // Similarly when getting column values as result, we could send a char*
  // buffer to read the result into instead of creating a new std::string
  // (though it is dangerous and should avoid unless perf benefit is proven)
  inline void setString(const char* val, const int32_t len) {
    if (len >= 0) {
      if (m_type & (GFXDType::VARCHAR
          | GFXDType::BINARY
          | GFXDType::JAVA_OBJECT)) {
        m_uval.string_binary_java_val->assign(val, len);
      }
      else {
        clearValue();
        m_uval.string_binary_java_val = new std::string(val, len);
      }
      m_type = GFXDType::VARCHAR;
    }
    else {
      setString(val);
    }
  }

  inline bool isSetDecimal() const throw () {
    return (m_type == GFXDType::DECIMAL);
  }

  inline Decimal* getDecimal() const throw () {
    return m_uval.decimal_val;
  }

  inline void setDecimal(const Decimal& val) {
    if (isSetDecimal()) {
      *m_uval.decimal_val = val;
    }
    else {
      clearValue();
      m_uval.decimal_val = new Decimal(val);
    }
    m_type = GFXDType::DECIMAL;
  }

  inline Decimal* initForDecimal() {
    if (isSetDecimal()) {
      return m_uval.decimal_val;
    }
    else {
      clearValue();
      m_uval.decimal_val = NULL;
      m_type = GFXDType::DECIMAL;
      return (m_uval.decimal_val = new Decimal());
    }
  }

  inline bool isSetDate() const throw () {
    return (m_type == GFXDType::DATE);
  }

  inline int64_t getDate() const throw () {
    return m_uval.date_time_epoch_val;
  }

  inline void setDate(const int64_t secsSinceEpoch) {
    clearValue();
    m_uval.date_time_epoch_val = secsSinceEpoch;
    m_type = GFXDType::DATE;
  }

  inline bool isSetTime() const throw () {
    return (m_type == GFXDType::TIME);
  }

  inline int64_t getTime() const throw () {
    return m_uval.date_time_epoch_val;
  }

  inline void setTime(const int64_t secsSinceEpoch) {
    clearValue();
    m_uval.date_time_epoch_val = secsSinceEpoch;
    m_type = GFXDType::TIME;
  }

  inline bool isSetTimestamp() const throw () {
    return (m_type == GFXDType::TIMESTAMP);
  }

  inline Timestamp getTimestamp() const throw ()
  {
    return Timestamp(m_uval.timestamp_val.epochTime,
        m_uval.timestamp_val.nanos);
  }

  inline int64_t getTimestampEpoch() const throw () {
    return m_uval.timestamp_val.epochTime;
  }

  inline int32_t getTimestampNanos() const throw () {
    return m_uval.timestamp_val.nanos;
  }

  inline void setTimestamp(const Timestamp& val) {
    clearValue();
    m_uval.timestamp_val.epochTime = val.secsSinceEpoch;
    m_uval.timestamp_val.nanos = val.nanos;
    m_type = GFXDType::TIMESTAMP;
  }

  inline void setTimestamp(const int64_t epochTime,
      const int32_t nanos) {
    clearValue();
    m_uval.timestamp_val.epochTime = epochTime;
    m_uval.timestamp_val.nanos = nanos;
    m_type = GFXDType::TIMESTAMP;
  }

  inline bool isSetBinary() const throw () {
    return (m_type == GFXDType::BINARY);
  }

  inline std::string* getBinary() const throw () {
    return m_uval.string_binary_java_val;
  }

  inline void setBinary(const std::string& val) {
    if (m_type & (GFXDType::VARCHAR
        | GFXDType::BINARY
        | GFXDType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(val);
    }
    else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(val);
    }
    m_type = GFXDType::BINARY;
  }

  inline void setBinary(const char* val, const size_t len) {
    if (m_type & (GFXDType::VARCHAR
        | GFXDType::BINARY
        | GFXDType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(val, len);
    }
    else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(val, len);
    }
    m_type = GFXDType::BINARY;
  }

  inline bool isSetBlob() const throw () {
    return (m_type == GFXDType::BLOB);
  }

  inline BlobChunk* getBlob() const throw () {
    return m_uval.blob_val;
  }

  inline void setBlob(const BlobChunk& val) {
    if (isSetBlob()) {
      *m_uval.blob_val = val;
    }
    else {
      clearValue();
      m_uval.blob_val = new BlobChunk(val);
    }
    m_type = GFXDType::BLOB;
  }

  inline bool isSetClob() const throw () {
    return (m_type == GFXDType::CLOB);
  }

  inline ClobChunk* getClob() const throw () {
    return m_uval.clob_val;
  }

  inline void setClob(const ClobChunk& val) {
    if (isSetClob()) {
      *m_uval.clob_val = val;
    }
    else {
      clearValue();
      m_uval.clob_val = new ClobChunk(val);
    }
    m_type = GFXDType::CLOB;
  }

  inline bool isNull() const throw () {
    return (m_type == GFXDType::NULLTYPE);
  }

  inline void setNull() {
    clearValue();
    m_uval.null_val = true;
    m_type = GFXDType::NULLTYPE;
  }

  inline bool isSetPDX() const throw () {
    return (m_type == GFXDType::PDX_OBJECT);
  }

  inline PDXObject* getPDX() const throw () {
    return m_uval.pdx_val;
  }

  inline void setPDX(const PDXObject& val) {
    if (isSetPDX()) {
      *m_uval.pdx_val = val;
    }
    else {
      clearValue();
      m_uval.pdx_val = new PDXObject(val);
    }
    m_type = GFXDType::PDX_OBJECT;
  }

  inline bool isSetJSON() const throw () {
    return (m_type == GFXDType::JSON_OBJECT);
  }

  inline JSONObject* getJSON() const throw () {
    return m_uval.json_val;
  }

  inline void setJSON(const JSONObject& val) {
    if (isSetJSON()) {
      *m_uval.json_val = val;
    }
    else {
      clearValue();
      m_uval.json_val = new JSONObject(val);
    }
    m_type = GFXDType::JSON_OBJECT;
  }

  inline bool isSetJavaVal() const throw () {
    return (m_type == GFXDType::JAVA_OBJECT);
  }

  inline std::string* getJavaVal() const throw () {
    return m_uval.string_binary_java_val;
  }

  inline void setJavaVal(const std::string& val) {
    if (m_type & (GFXDType::VARCHAR
        | GFXDType::BINARY
        | GFXDType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(val);
    }
    else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(val);
    }
    m_type = GFXDType::JAVA_OBJECT;
  }

#if __cplusplus >= 201103L
  inline void setString(std::string&& val) {
    if (m_type & (GFXDType::VARCHAR
        | GFXDType::BINARY
        | GFXDType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(std::move(val));
    }
    else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(std::move(val));
    }
    m_type = GFXDType::VARCHAR;
  }

  inline void setDecimal(Decimal&& val) {
    if (isSetDecimal()) {
      m_uval.decimal_val->assign(std::move(val));
    }
    else {
      clearValue();
      m_uval.decimal_val = new Decimal(std::move(val));
    }
    m_type = GFXDType::DECIMAL;
  }

  inline void setBinary(std::string&& val) {
    if (m_type & (GFXDType::VARCHAR
        | GFXDType::BINARY
        | GFXDType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(std::move(val));
    }
    else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(std::move(val));
    }
    m_type = GFXDType::BINARY;
  }

  inline void setBlob(BlobChunk&& val) {
    if (isSetBlob()) {
      m_uval.blob_val->assign(std::move(val));
    }
    else {
      clearValue();
      m_uval.blob_val = new BlobChunk(std::move(val));
    }
    m_type = GFXDType::BLOB;
  }

  inline void setClob(ClobChunk&& val) {
    if (isSetClob()) {
      m_uval.clob_val->assign(std::move(val));
    }
    else {
      clearValue();
      m_uval.clob_val = new ClobChunk(std::move(val));
    }
    m_type = GFXDType::CLOB;
  }

  inline void setPDX(PDXObject&& val) {
    if (isSetPDX()) {
      m_uval.pdx_val->assign(std::move(val));
    }
    else {
      clearValue();
      m_uval.pdx_val = new PDXObject(std::move(val));
    }
    m_type = GFXDType::PDX_OBJECT;
  }

  inline void setJSON(JSONObject&& val) {
    if (isSetJSON()) {
      m_uval.json_val->assign(std::move(val));
    }
    else {
      clearValue();
      m_uval.json_val = new JSONObject(std::move(val));
    }
    m_type = GFXDType::JSON_OBJECT;
  }

  inline void setJavaVal(std::string&& val) {
    if (m_type & (GFXDType::VARCHAR
        | GFXDType::BINARY
        | GFXDType::JAVA_OBJECT)) {
      m_uval.string_binary_java_val->assign(std::move(val));
    }
    else {
      clearValue();
      m_uval.string_binary_java_val = new std::string(std::move(val));
    }
    m_type = GFXDType::JAVA_OBJECT;
  }

#endif

  bool operator == (const ColumnValue & rhs) const
  {
    const GFXDType::type type = m_type;
    if (type != rhs.m_type)
      return false;
    switch (type) {
      case GFXDType::VARCHAR:
      case GFXDType::CHAR:
      case GFXDType::LONGVARCHAR:
      case GFXDType::BINARY:
      case GFXDType::LONGVARBINARY:
      case GFXDType::JAVA_OBJECT:
        return *m_uval.string_binary_java_val
            == *rhs.m_uval.string_binary_java_val;
      case GFXDType::DECIMAL:
        return *m_uval.decimal_val == *rhs.m_uval.decimal_val;
      case GFXDType::BIGINT:
        return m_uval.i64_val == rhs.m_uval.i64_val;
      case GFXDType::BOOLEAN:
        return m_uval.bool_val == rhs.m_uval.bool_val;
      case GFXDType::DATE:
        return m_uval.date_time_epoch_val == rhs.m_uval.date_time_epoch_val;
      case GFXDType::DOUBLE:
        return m_uval.double_val == rhs.m_uval.double_val;
      case GFXDType::FLOAT:
        return m_uval.float_val == rhs.m_uval.float_val;
      case GFXDType::INTEGER:
        return m_uval.i32_val == rhs.m_uval.i32_val;
      case GFXDType::NULLTYPE:
        return true;
      case GFXDType::SMALLINT:
        return m_uval.i16_val == rhs.m_uval.i16_val;
      case GFXDType::TIME:
        return m_uval.date_time_epoch_val == rhs.m_uval.date_time_epoch_val;
      case GFXDType::TIMESTAMP:
        return m_uval.timestamp_val == rhs.m_uval.timestamp_val;
      case GFXDType::TINYINT:
        return m_uval.byte_val == rhs.m_uval.byte_val;
      case GFXDType::BLOB:
        return *m_uval.blob_val == *rhs.m_uval.blob_val;
      case GFXDType::CLOB:
        return *m_uval.clob_val == *rhs.m_uval.clob_val;
      case GFXDType::JSON_OBJECT:
        return *m_uval.json_val == *rhs.m_uval.json_val;
      case GFXDType::PDX_OBJECT:
        return *m_uval.pdx_val == *rhs.m_uval.pdx_val;
      default:
        return ::memcmp(&m_uval, &rhs.m_uval, sizeof(m_uval)) == 0;
    }
  }
  bool operator != (const ColumnValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  void swap(ColumnValue& other);
};

void swap(ColumnValue &a, ColumnValue &b);

}}}} // namespace

#endif
